# Snippets for Go

priority 0

snippet im "import"
import (
	"${1:package}"
)
${0:${VISUAL}}
endsnippet

snippet type "type T struct { ... }"
type ${1:data} struct { ${0} }
${0:${VISUAL}}
endsnippet

snippet main "func main()"
func main() {
	${1}
}
${0:${VISUAL}}
endsnippet

snippet func "function"
func ${1:funcName}(${2}) ${3:error} {
	${4}
}
${0:${VISUAL}}
endsnippet

snippet rt "return"
return
endsnippet

snippet var "variables declaration"
var (
	${1} ${2} = ${3}
)
${0:${VISUAL}}
endsnippet

snippet fl "float64"
float64
endsnippet

snippet maxi "max value of int(int64)"
${1:x} := math.MaxInt64
${0:${VISUAL}}
endsnippet

snippet mini "min value of int(int64)"
${1:x} := math.MinInt64
${0:${VISUAL}}
endsnippet

snippet maxf "max value of float(float64)"
${1:x} := math.MaxFloat64
${0:${VISUAL}}
endsnippet

snippet minf "min value of float(float64)"
${1:x} := math.SmallestNonzeroFloat64
${0:${VISUAL}}
endsnippet

snippet fs "fmt.Scan(...)"
fmt.Scan(&${1:n})
${0:${VISUAL}}
endsnippet

snippet if "if ... { ... }"
if ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

snippet ef " else if ... { ... }"
else if ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

snippet else "else ... { ... }"
else {
	${0:${VISUAL}}
}
endsnippet

snippet ok  "if _, ok := xm[x]; ok { ... }"
if _, ok := ${1:xm}[${2:x}]; ok {
	${0:${VISUAL}}
}
endsnippet

snippet for "for ... { ... }"
for ${1} {
	${0:${VISUAL}}
}
endsnippet

snippet fori "for 0..n-1 { ... }"
for ${1:i} := 0; $1 < ${2:n}; $1++ {
	${0:${VISUAL}}
}
endsnippet

snippet forir "for n..0 { ... }"
for ${1:i} := ${2:n - 1}; $1 >= 0; $1-- {
	${0:${VISUAL}}
}
endsnippet

snippet forr "for i, v := range items { ... }"
for ${2:i}, ${3:v} := range ${1:xs} {
	${0:${VISUAL}}
}
endsnippet

snippet forri "for i := range items { ... }"
for ${2:i} := range ${1:xs} {
	${0:${VISUAL}}
}
endsnippet

snippet forrv "for _, v := range items { ... }"
for _, ${2:v} := range ${1:xs} {
	${0:${VISUAL}}
}
endsnippet

snippet cn "continue"
continue
endsnippet

snippet br "break"
break
endsnippet

snippet sw "switch"
switch ${1:var} {
case ${2:value1}:
	${3}
case ${4:value2}:
	${5}
default:
	${0:${VISUAL}}
}
endsnippet

snippet ap "append"
${1:slice} = append($1, ${2:value})
${0:${VISUAL}}
endsnippet

snippet itoa "strconv.Itoa(...)"
strconv.Itoa(${1:n})
endsnippet

snippet atoi "..., _ := strconv.Atoi(...)"
${1:x}, _ := strconv.Atoi(${2:s})
${0:${VISUAL}}
endsnippet

snippet atof "..., _ := strconv.ParseFloat(...)"
${1:x}, _ := strconv.ParseFloat(${2:s}, 64)
${0:${VISUAL}}
endsnippet

snippet split "... := strings.Split(..., ...)"
${1:xs} := strings.Split(${2:s}, "${3: }")
${0:${VISUAL}}
endsnippet

snippet fn "fmt.Println(...)"
fmt.Println(${1:x})
endsnippet

snippet ff "fmt.Printf(...)"
fmt.Printf("%v\n", ${1:x})
endsnippet

snippet timeymd "get time from yyyy/mm/dd"
x := strings.Split(s, "/")
y, _ := strconv.Atoi(x[0])
m, _ := strconv.Atoi(x[1])
d, _ := strconv.Atoi(x[2])
t := time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.UTC)
fmt.Println(t)

endsnippet

snippet ans "variable for answer"
ans := 0
fmt.Println(ans)
endsnippet

snippet mod "a prime number used many times in programing contest"
const mod = 1000000007
${0:${VISUAL}}
endsnippet

snippet az "string which is a to z"
az := "abcdefghijklmnopqrstuvwxyz"
${0:${VISUAL}}
endsnippet

snippet dxy "move x and y in 4 way of 2 dimensional"
dx := []int{0, 1, 0, -1}
dy := []int{1, 0, -1, 0}

for ${1:k} := 0; $1 < 4; $1++ {
	nx, ny := j+dx[$1], i+dy[$1]
	if nx < 0 || nx >= w || ny < 0 || ny >= h || s[ny][nx] == '#' {
		continue
	}
}
${0:${VISUAL}}
endsnippet

snippet dxy8 "move x and y in 8 way of 2 dimensional"
dx := []int{0, 1, 1, 1, 0, -1, -1, -1}
dy := []int{1, 1, 0, -1, -1, -1, 0, 1}

for ${1:k} := 0; $1 < 8; $1++ {
	nx, ny := j+dx[$1], i+dy[$1]
	if nx < 0 || nx >= w || ny < 0 || ny >= h || s[ny][nx] == '#' {
		continue
	}
}
${0:${VISUAL}}
endsnippet

snippet fs1 "make variable(int) and use fmt.Scan(...)"
var ${1:n} ${2:int}
fmt.Scan(&$1)
${0:${VISUAL}}
endsnippet

snippet fs2 "make two variables and use fmt.Scan(...)"
var ${1:a}, ${2:b} ${3:int}
fmt.Scan(&$1, &$2)
${0:${VISUAL}}
endsnippet

snippet fs3 "make three variables and use fmt.Scan(...)"
var ${1:a}, ${2:b}, ${3:c} ${4:int}
fmt.Scan(&$1, &$2, &$3)
${0:${VISUAL}}
endsnippet

snippet fs4 "make four variables and use fmt.Scan(...)"
var ${1:a}, ${2:b}, ${3:c}, ${4:d} ${5:int}
fmt.Scan(&$1, &$2, &$3, &$4)
${0:${VISUAL}}
endsnippet

snippet fs5 "make five variables and use fmt.Scan(...)"
var ${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:e} ${6:int}
fmt.Scan(&$1, &$2, &$3, &$4, &$5)
${0:${VISUAL}}
endsnippet

snippet fsis "make variables(int, string) and use fmt.Scan(...)"
var (
	${1:n} int
	${2:s} string
)
fmt.Scan(&$1, &$2)
${0:${VISUAL}}
endsnippet

snippet fssi "make variables(string, int) and use fmt.Scan(...)"
var (
	${1:s} string
	${2:n} int
)
fmt.Scan(&$1, &$2)
${0:${VISUAL}}
endsnippet

snippet si "scan standard input as integer"
var sc = bufio.NewScanner(os.Stdin)

func scanInt() int {
	sc.Scan()
	iv, _ := strconv.Atoi(sc.Text())
	return iv
}

func init() {
	sc.Split(bufio.ScanWords)
}

endsnippet

snippet si1 "... := scanInt()"
${1:n} := scanInt()
${0:${VISUAL}}
endsnippet

snippet si2 "... := scanInt(), scanInt()"
${1:a}, ${2:b} := scanInt(), scanInt()
${0:${VISUAL}}
endsnippet

snippet si3 "... := scanInt(), scanInt(), scanInt()"
${1:a}, ${2:b}, ${3:c} := scanInt(), scanInt(), scanInt()
${0:${VISUAL}}
endsnippet

snippet si4 "... := scanInt(), scanInt(), scanInt(), scanInt()"
${1:a}, ${2:b}, ${3:c}, ${4:d} := scanInt(), scanInt(), scanInt(), scanInt()
${0:${VISUAL}}
endsnippet

snippet si5 "... := scanInt(), scanInt(), scanInt(), scanInt(), scanInt()"
${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:e} := scanInt(), scanInt(), scanInt(), scanInt(), scanInt()
${0:${VISUAL}}
endsnippet

snippet ss "scan standard input as string"
var sc = bufio.NewScanner(os.Stdin)

func scanString() string {
	sc.Scan()
	return sc.Text()
}

func init() {
	sc.Split(bufio.Scan${1:Words})
	sc.Buffer(make([]byte, 100000), 100000000)
}
${0:${VISUAL}}
endsnippet

snippet ss1 "... := scanString()"
${1:s} := scanString()
${0:${VISUAL}}
endsnippet

snippet ss2 "... := scanString(), scanString()"
${1:a}, ${2:b} := scanString(), scanString()
${0:${VISUAL}}
endsnippet

snippet ss3 "... := scanString(), scanString(), scanString()"
${1:a}, ${2:b}, ${3:c} := scanString(), scanString(), scanString()
${0:${VISUAL}}
endsnippet

snippet ss4 "... := scanString(), scanString(), scanString(), scanString()"
${1:a}, ${2:b}, ${3:c}, ${4:d} := scanString(), scanString(), scanString(), scanString()
${0:${VISUAL}}
endsnippet

snippet ss5 "... := scanString(), scanString(), scanString(), scanString(), scanString()"
${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:e} := scanString(), scanString(), scanString(), scanString(), scanString()
${0:${VISUAL}}
endsnippet

snippet sis "read standard input by scanner and return value as integer or string"
var sc = bufio.NewScanner(os.Stdin)

func scanInt() int {
	iv, _ := strconv.Atoi(scanString())
	return iv
}

func scanString() string {
	sc.Scan()
	return sc.Text()
}

func init() {
	sc.Split(bufio.Scan${1:Words})
	sc.Buffer(make([]byte, 100000), 100000000)
}
${0:${VISUAL}}
endsnippet

snippet ms "make slice"
${1:xs} := make([]${3:int}, ${2:n})
for i := range $1 {
	$1[i] = scanInt()
}
${0:${VISUAL}}
endsnippet

snippet mms "make multiple slice"
${1:xs} := make([][]int, ${2:n})
for ${4:i} := range $1 {
	$1[$4] = make([]int, ${3:k})
	for ${5:j} := range $1[$4] {
		$1[$4][$5] = scanInt()
	}
}
${0:${VISUAL}}
endsnippet

snippet mm "make map"
${1:xm} := make(map[${2:int}]${3:bool})
${0:${VISUAL}}
endsnippet

snippet mmm "make mapped map"
${1:xm} := make(map[int]map[int]bool, ${2:n})
for i := 0; i < ${3:m}; i++ {
	${4:a}, ${5:b} := scanInt(), scanInt()
	if _, ok := $1[$4]; !ok {
		$1[$4] = make(map[int]bool)
	}
	$1[$4][$5] = true
}
${0:${VISUAL}}
endsnippet

snippet revs "reverse a string"
${1:rs} := make([]string, ${2:n})
for i := range ${3:s} {
	${4:r} := []rune($3[i])
	for i, j := 0, len($4)-1; i < j; i, j = i+1, j-1 {
		$4[i], $4[j] = $4[j], $4[i]
	}
	$1[i] = string($4)
}
${0:${VISUAL}}
endsnippet

snippet forb "for loop and bit full search"
for ${2:i} := 1; $2 < 1<<uint(${1:n}); $2++ {
	for ${3:j} := 0; $3 < $1; $3++ {
		if ${4:b} := 1 << uint($3); $2&$4 == $4 {
			${0:${VISUAL}}
		}
	}
}
endsnippet

snippet sort "sort.Slice(...)"
sort.Slice(${1:xs}, func(i, j int) bool { return $1[i].${2:val} < $1[j].$2 })
${0:${VISUAL}}
endsnippet

snippet sorts "sort string by character"
${1:xs} := []rune(${2:s})
sort.Slice($1, func(i, j int) bool { return $1[i] < $1[j] })
${0:${VISUAL}}
endsnippet

snippet sortr "sort reversely for Ints"
sort.Sort(sort.Reverse(sort.IntSlice(${1:xs})))
${0:${VISUAL}}
endsnippet

snippet sortit "sort by interface"
type ${1:data} struct{ ${2:x}, ${3:y} int }
type ${4:datas} []$1

func (${5:d} $4) Len() int           { return len($5) }
func ($5 $4) Swap(i, j int)      { $5[i], $5[j] = $5[j], $5[i] }
func ($5 $4) Less(i, j int) bool { return $5[i].$2 < $5[j].$2 }

${6:xs}:= $4(make([]$1, ${7:n}))
sort.Sort($6)
endsnippet

snippet search "sort.Search(...)"
${1:idx} := sort.Search(len(${2:xs}), func(i int) bool { return $2[i] >= ${3:x} })
${0:${VISUAL}}
endsnippet

snippet searchi "sort.SearchInts(...)"
${1:idx} := sort.SearchInts(${2:xs}, ${3:x})
${0:${VISUAL}}
endsnippet

snippet list "use container/list of integers"
ls := list.New()
for i := 0; i < ${1:n}; i++ {
	ls.PushBack(i)
}

for e := ls.Front(); e != nil; e = e.Next() {
	v := e.Value.(int)
	fmt.Println(v)
}

for ls.Len() > 0 {
	v := ls.Remove(ls.Front()).(int)
	fmt.Println(v)
}
endsnippet

snippet pq "get priority queue"
type ${1:data} struct{ ${2:x}, ${3:y} int }
type prQue []*$1

func (p prQue) Len() int            { return len(p) }
func (p prQue) Less(i, j int) bool  { return p[i].$2 > p[j].$2 }
func (p prQue) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }
func (p *prQue) Push(x interface{}) { *p = append(*p, x.(*$1)) }
func (p *prQue) Pop() interface{} {
	old := *p
	n := len(old)
	x := old[n-1]
	*p = old[0 : n-1]
	return x
}

pq := make(prQue, 0, ${4:n})
heap.Push(&pq, &$1{2, 1})
heap.Push(&pq, &$1{3, 2})
heap.Push(&pq, &$1{1, 3})
for len(pq) > 0 {
	v := heap.Pop(&pq).(*$1)
}
endsnippet

snippet pqi "get priority queue of integers"
type prQue []int

func (p prQue) Len() int            { return len(p) }
func (p prQue) Less(i, j int) bool  { return p[i] > p[j] }
func (p prQue) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }
func (p *prQue) Push(x interface{}) { *p = append(*p, x.(int)) }
func (p *prQue) Pop() interface{} {
	old := *p
	n := len(old)
	x := old[n-1]
	*p = old[0 : n-1]
	return x
}

pq := make(prQue, 0, ${1:n})
heap.Push(&pq, 1)
heap.Push(&pq, 3)
heap.Push(&pq, 2)
for len(pq) > 0 {
	v := heap.Pop(&pq).(int)
}
endsnippet

snippet abs "get absolute value of an integer"
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

endsnippet

snippet max "get maximum value of two integers"
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

endsnippet

snippet maxs "get maximum value of multiple integers"
func maxs(x ...int) int {
	mv := x[0]
	for _, v := range x[1:] {
		if v > mv {
			mv = v
		}
	}
	return mv
}

endsnippet

snippet min "get minimum value of two integers"
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

endsnippet

snippet mins "get minimum value of multiple integers"
func mins(x ...int) int {
	mv := x[0]
	for _, v := range x[1:] {
		if v < mv {
			mv = v
		}
	}
	return mv
}

endsnippet

snippet gcd "get GCD(Greatest Common Divisor)"
func gcd(x, y int) int {
	for y > 0 {
		x, y = y, x%y
	}
	return x
}

endsnippet

snippet lcm "get LCM(Least Common Multiple)"
func gcd(x, y int) int {
	for y > 0 {
		x, y = y, x%y
	}
	return x
}

func lcm(x, y int) int {
	return x / gcd(x, y) * y
}

endsnippet

snippet prm "get answer which is Prime Number or not"
func isPrime(x int) bool {
	if x < 2 {
		return false
	}

	for i := 2; i*i <= x; i++ {
		if x%i == 0 {
			return false
		}
	}
	return true
}

endsnippet

snippet prf "get answer of Prime Factorization"
func prmFac(x int) map[int]bool {
	pfm := make(map[int]bool)
	pfm[1] = true
	for i := 2; i*i <= x; i++ {
		for x%i == 0 {
			x /= i
			pfm[i] = true
		}
	}
	if x > 1 {
		pfm[x] = true
	}
	return pfm
}

endsnippet

snippet per "get permutations array"
func permutations(xs []int) [][]int {
	l := 1
	for i := 2; i <= len(xs); i++ {
		l *= i
	}
	ans := make([][]int, 0, l)

	var rec func([]int, int)
	rec = func(xs []int, n int) {
		if n == 1 {
			tmp := make([]int, len(xs))
			copy(tmp, xs)
			ans = append(ans, tmp)
			return
		}
		for i := 0; i < n; i++ {
			rec(xs, n-1)
			if n%2 == 1 {
				xs[i], xs[n-1] = xs[n-1], xs[i]
				continue
			}
			xs[0], xs[n-1] = xs[n-1], xs[0]
		}
	}
	rec(xs, len(xs))
	return ans
}

x := []int{${1:1, 2, 3}}
permutations(x)
endsnippet

snippet base "Get N-based numeral string"
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func base(x, b int) string {
	bs := ""
	for x > 0 {
		r := abs(x % b)
		bs = strconv.Itoa(r) + bs
		x -= r
		x /= b
	}
	if bs == "" {
		bs = "0"
	}
	return bs
}

base(${1:n}, ${2:2})
endsnippet

snippet pow "get x**y the base-x exponential of y by mod"
const mod = 1000000007

func pow(x, y int) int {
	if y == 0 {
		return 1
	} else if y%2 == 0 {
		x2 := pow(x, y/2)
		return x2 * x2 % mod
	} else {
		return x * pow(x, y-1) % mod
	}
}

endsnippet

snippet cmb "get combination value by using inverse element"
const mod = 1000000007

func pow(x, y int) int {
	if y == 0 {
		return 1
	} else if y%2 == 0 {
		x2 := pow(x, y/2)
		return x2 * x2 % mod
	} else {
		return x * pow(x, y-1) % mod
	}
}

func cmb(x, y int) int {
	if y > x {
		return 0
	}

	nu, de := 1, 1
	for i := 0; i < y; i++ {
		nu = nu * (x - i) % mod
		de = de * (i + 1) % mod
	}
	return nu * pow(de, mod-2) % mod
}

endsnippet

snippet cmbs "get combination value by using inverse element and slice"
const mod = 1000000007

var fac, finv, inv []int

func initCmb(x int) {
	fac, finv, inv = make([]int, x+1), make([]int, x+1), make([]int, x+1)
	fac[0], fac[1] = 1, 1
	finv[0], finv[1] = 1, 1
	inv[1] = 1
	for i := 2; i <= x; i++ {
		fac[i] = fac[i-1] * i % mod
		inv[i] = mod - inv[mod%i]*(mod/i)%mod
		finv[i] = finv[i-1] * inv[i] % mod
	}
}

func cmb(x, y int) int {
	if y > x {
		return 0
	}
	return fac[x] * (finv[y] * finv[x-y] % mod) % mod
}

initCmb(${1:n})
cmb($1, ${2:k})
endsnippet

snippet cmbp "get combination value by Pascal's triangle"
const mod = 1000000007

var cs [][]int

func initCmb(x int) {
	cs = make([][]int, x+1)
	for i := range cs {
		cs[i] = make([]int, i+1)
		cs[i][0], cs[i][len(cs[i])-1] = 1, 1
		for j := 1; j < len(cs[i])-1; j++ {
			cs[i][j] = (cs[i-1][j-1] + cs[i-1][j]) % mod
		}
	}
}

func cmb(x, y int) int {
	if y > x {
		return 0
	}
	return cs[x][y]
}

initCmb(${1:n})
cmb($1, ${2:k})
endsnippet

snippet fac "get factorial value"
func fac(x int) int {
	fv := 1
	for i := x; i > 0; i-- {
		fv *= i
	}
	return fv
}

endsnippet

snippet fib "get fibonacci value"
func fib(x int) int {
	a, b := 0, 1
	for i := 0; i < x; i++ {
		a, b = b, a+b
	}
	return a
}

endsnippet

snippet dfsn "Depth First Search in number combination"
var (
	${1:n}, ${2:m} int
	${3:ns}   [][]int
)

func dfs(xs []int) {
	if len(xs) == $1 {
		$3 = append($3, xs)
		return
	}

	for i := xs[len(xs)-1]; i <= $2; i++ {
		dfs(append(xs, i))
	}
}

$1, $2 = scanInt(), scanInt()
$3 = make([][]int, 0, ${4:100000})
for i := 1; i <= $2; i++ {
	dfs([]int{i})
}
endsnippet

snippet gr "Data structure for graph"
var graph map[int]map[int]bool

func initGraph(x int) {
	graph = make(map[int]map[int]bool, x)
}

func add(from, to int) {
	if _, ok := graph[from]; !ok {
		graph[from] = make(map[int]bool)
	}
	graph[from][to] = true
}

${1:n}, ${2:m} := scanInt(), scanInt()
initGraph($1)
for i := 0; i < $2; i++ {
	${3:a}, ${4:b} := scanInt(), scanInt()
	add($3, $4)
	add($4, $3)
}
endsnippet

snippet grw "Data structure for graph with weight"
var graph map[int]map[int]int

func initGraph(x int) {
	graph = make(map[int]map[int]int, x)
}

func add(from, to, weight int) {
	if _, ok := graph[from]; !ok {
		graph[from] = make(map[int]int)
	}
	graph[from][to] = weight
}

${1:n}, ${2:m} := scanInt(), scanInt()
initGraph($1)
for i := 0; i < $2; i++ {
	${3:a}, ${4:b}, ${5:c} := scanInt(), scanInt(), scanInt()
	add($3, $4, $5)
	add($4, $3, $5)
}
endsnippet

snippet dfs "Depth First Search in graph"
var seen []bool

func dfs(v int) {
	seen[v] = true
	for t := range graph[v] {
		if seen[t] {
			continue
		}
		dfs(t)
	}
}

seen := make([]bool, n+1)
dfs(1)
endsnippet

snippet sdfs "Get shortest path in graph by Depth First Search"
var depth []int

func dfs(v, p, d int) {
	depth[v] = d
	for t, w := range graph[v] {
		if t == p {
			continue
		}
		dfs(t, v, d+w)
	}
}

depth = make([]int, n+1)
dfs(${1:k}, -1, 0)
fmt.Println(depth)
endsnippet

snippet bfs "Breadth First Search in graph"
seen := make([]bool, n+1)
ls := list.New()
ls.PushBack(${1:1})
seen[$1] = true
for ls.Len() > 0 {
	v := ls.Remove(ls.Front()).(int)
	for t := range graph[v] {
		if seen[t] {
			continue
		}
		seen[t] = true
		ls.PushBack(t)
	}
}
${0:${VISUAL}}
endsnippet

snippet war "Warshall Floyd Algorithm"
${1:n} := scanInt()
${2:dist} := make([][]int, $1)
for i := range $2 {
	$2[i] = make([]int, $1)
	for j := 0; j < $1; j++ {
		if i == j {
			continue
		}
		$2[i][j] = ${3:1001*300}
	}
}

${4:m} := scanInt()
for i := 0; i < $4; i++ {
	a, b, t := scanInt(), scanInt(), scanInt()
	a--
	b--
	$2[a][b] = t
	$2[b][a] = t
}

for k := 0; k < $1; k++ {
	for i := 0; i < $1; i++ {
		for j := 0; j < $1; j++ {
			$2[i][j] = min($2[i][j], $2[i][k]+$2[k][j])
		}
	}
}

ans := math.MaxInt64
for i := range $2 {
	x := 0
	for j := range $2[i] {
		x = max(x, $2[i][j])
	}
	ans = min(ans, x)
}
fmt.Println(ans)
endsnippet

snippet uft "get Union Find Tree"
var (
	par  []int
	rank []int
)

func initTree(x int) {
	par = make([]int, x+1)
	rank = make([]int, x+1)
	for i := range par {
		par[i] = i
	}
}

func find(x int) int {
	if par[x] == x {
		return x
	}
	par[x] = find(par[x])
	return par[x]
}

func union(x, y int) {
	px, py := find(x), find(y)
	if px == py {
		return
	}
	if rank[px] < rank[py] {
		par[px] = py
		return
	} else if rank[px] == rank[py] {
		rank[px]++
	}
	par[py] = px
}

initTree(${1:n})
union(1, 2)
union(2, 3)
union(4, 5)
for i := 1; i <= $1; i++ {
	f := find(i)
}
endsnippet

snippet wr "write standard output by writer"
wr := bufio.NewWriter(os.Stdout)

wr.WriteString(strconv.Itoa(${1:n}) + "\n")
wr.WriteString(strconv.Itoa($1))
wr.WriteString("\n")
wr.Flush()
endsnippet

global !p

import re

# Automatically wrap return types with parentheses

def return_values(s):
	# remove everything wrapped in parentheses
	s = re.sub("\(.*?\)|\([^)]*$", "", s)
	return len(s.split(","))

def opening_par(snip, pos):
	if return_values(t[pos]) > 1 and not t[pos].startswith("("):
		snip.rv = "("
	else:
		snip.rv = ""

def closing_par(snip, pos):
	if return_values(t[pos]) > 1:
		snip.rv = ")"
	else:
		snip.rv = ""

endglobal

# vim:ft=snippets:
