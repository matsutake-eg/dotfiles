priority 0

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header

snippet rt "return" b
return${1:};
endsnippet

snippet br "break" b
break;
endsnippet

snippet cn "continue" b
continue;
endsnippet

snippet ans "variable for answer" b
let mut ans = 0;
${0:${VISUAL}}
println!("{}", ans);
endsnippet

snippet inte "interactive input" b
// remove #[fastout] and comment
let ${1:n} = read_line::<${2:usize}>();
fn get_line() -> String {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).ok();
    s.trim().to_string()
}

fn read_line<T>() -> T
where
    T: std::str::FromStr,
    <T as std::str::FromStr>::Err: std::fmt::Debug,
{
    get_line().parse().unwrap()
}
endsnippet

snippet pt "println!"
println!("{${1:}}", ${2:n});
endsnippet

snippet pts "println! with simple(no parameter)"
println!("${1:Yes}");
endsnippet

snippet cond "conditional operator"
if ${1:n < 0} { ${2:"Yes"} } else { ${3:"No"} }
endsnippet
 
snippet for "for ... in ..." b
for ${1:v} in ${2:a} {
    ${0:${VISUAL}}
}
endsnippet

snippet fore "for ... in ....into_iter().enumerate()" b
for (${1:i}, ${2:v}) in ${3:a}.into_iter().enumerate() {
    ${0:${VISUAL}}
}
endsnippet

snippet forr "reverse for ... in ..." b
for ${1:v} in ${2:a}.into_iter().rev() {
    ${0:${VISUAL}}
}
endsnippet

snippet forer "for ... in ....into_iter().rev().enumerate()" b
for (${1:i}, ${2:v}) in ${3:a}.into_iter().rev().enumerate() {
    ${0:${VISUAL}}
}
endsnippet

snippet wh "while" b
while ${1:n > 0} {
    ${0:${VISUAL}}
}
endsnippet

snippet ve "vec!, Vec macro"
let mut ${2:x} = vec![0; ${1:n}];
${0:${VISUAL}}
endsnippet

snippet ven "Vec::new()"
let mut ${1:x} = Vec::new();
${0:${VISUAL}}
endsnippet

snippet hs "HashSet::new()"
let mut ${1:x} = HashSet::new();
${0:${VISUAL}}
endsnippet

snippet hm "HashMap::new()"
let mut ${1:x} = HashMap::new();
${0:${VISUAL}}
endsnippet

snippet vd " VecDeque::new()"
let mut ${1:x} = VecDeque::new();
${0:${VISUAL}}
endsnippet

snippet ntos "parse number to String"
let ${2:s} = ${1:n}.to_string();
${0:${VISUAL}}
endsnippet

snippet ston "parse String to number"
let ${3:n} = ${1:s}.parse::<${2:usize}>().unwrap();
${0:${VISUAL}}
endsnippet

snippet stoc "parse String to Vec<char>"
let ${2:cs} = ${1:s}.chars().collect::<Vec<_>>();
${0:${VISUAL}}
endsnippet

snippet ctos "parse Vec<char> to String"
let ${2:s} = ${1:cs}.into_iter().collect::<String>();
${0:${VISUAL}}
endsnippet

snippet ntoc "parse number to Vec<char>"
let ${2:cs} = ${1:n}.to_string().chars().collect::<Vec<_>>();
${0:${VISUAL}}
endsnippet

snippet cton "parse Vec<char> to number"
let ${2:n} = ${1:cs}.into_iter().collect::<String>().parse::<usize>().unwrap();
${0:${VISUAL}}
endsnippet

snippet con "concat String"
let ${3:s} = [${1:s}, ${2:t}].concat();
${0:${VISUAL}}
endsnippet

snippet join "same as 'con', concat String"
let ${3:s} = [${1:s}, ${2:t}].concat();
${0:${VISUAL}}
endsnippet

snippet revs "reverse string"
let ${2:s} = ${1:s}.chars().rev().collect::<Vec<_>>().into_iter().collect::<String>();
${0:${VISUAL}}
endsnippet

snippet maxi "get max value from Iterator"
let ${2:max_x} = ${1:x}.into_iter().max().unwrap();
${0:${VISUAL}}
endsnippet

snippet maxmi "get max value from multiple Iterator"
let ${2:max_x} = ${1:x}.into_iter().map(|x| x.into_iter().max().unwrap()).max().unwrap();
${0:${VISUAL}}
endsnippet

snippet maxv "get max value from HashMap"
let ${2:v} = ${1:x}.values().max().unwrap();
endsnippet

snippet maxk "get max key from HashMap"
let ${2:k} = ${1:x}.into_iter().max_by_key(|x| x.1).unwrap().0;
endsnippet

snippet mini "get min value from Iterator"
let ${2:min_x} = ${1:x}.into_iter().min().unwrap();
${0:${VISUAL}}
endsnippet

snippet minmi "get min value from multiple Iterator"
let ${2:min_x} = ${1:x}.into_iter().map(|x| x.into_iter().min().unwrap()).min().unwrap();
${0:${VISUAL}}
endsnippet

snippet minv "get min value from HashMap"
let ${2:v} = ${1:x}.values().min().unwrap();
endsnippet

snippet mink "get min key from HashMap"
let ${2:k} = ${1:x}.into_iter().min_by_key(|x| x.1).unwrap().0;
endsnippet

snippet indi "get index from Iterator"
let ${3:idx} = ${1:x}.into_iter().position(|x| x == ${2:v}).unwrap();
${0:${VISUAL}}
endsnippet

snippet hcou "count in HashMap" b
*${1:x}.entry(${2:k}).or_insert(0) += 1;
endsnippet

snippet fol "an iterator method that applies a function, producing a single, final value."
${1:x}.iter().fold($1[0], |acc, &x| gcd(acc, x));
${0:${VISUAL}}
endsnippet

snippet redu "Same as 'fold', an iterator method that applies a function, producing a single, final value."
${1:x}.iter().fold($1[0], |acc, &x| gcd(acc, x));
${0:${VISUAL}}
endsnippet

snippet map "map function"
let ${3:x} = ${1:x}.into_iter().map(|x| x * 2).collect::<Vec<${2:usize}>>();
${0:${VISUAL}}
endsnippet

snippet fil "filter function"
let ${3:x} = ${1:x}.into_iter().filter(|x| x % 2 == 0).collect::<Vec<${2:usize}>>();
${0:${VISUAL}}
endsnippet

snippet sum "get sum value"
let ${3:sum_x} = ${1:x}.into_iter().sum::<${2:usize}>();
${0:${VISUAL}}
endsnippet

snippet csum "get cumulative sum" b
let ${3:csum_x} = ${1:x}.into_iter().cumsum().collect::<Vec<${2:usize}>>();
endsnippet

snippet csumz "get cumulative sum with inserting zero" b
let ${3:csum_x} = std::iter::once(&0)
    .chain(&${1:x})
    .cumsum()
    .collect::<Vec<${2:usize}>>();
endsnippet

snippet sort "sort Vector" b
let mut ${1:x} = $1;
$1.sort();
${0:${VISUAL}}
endsnippet

snippet sortr "sort Vector reversely" b
let mut ${1:x} = $1;
$1.sort();
$1.reverse();
${0:${VISUAL}}
endsnippet

snippet sortf "sort Vector with function" b
let mut ${1:ab} = $1;
$1.sort_by(|a, b| (&a.1).cmp(&b.1));
${0:${VISUAL}}
endsnippet

snippet bis "binary search" b
let ${3:idx} = ${1:x}.binary_search(&${2:v}).unwrap_or_else(|x| x);
${0:${VISUAL}}
endsnippet

snippet bisf "binary search by function" b
let ${2:idx} = ${1:x}.binary_search_by(|x| ((1 + x) * x / 2).cmp(&(n + 1))).unwrap_or_else(|x| x);
${0:${VISUAL}}
endsnippet

snippet bism "binary search manually" b
let (mut l, mut r) = (1, n + 1);
while r - l > 1 {
    let m = (l + r) / 2;
    if (1 + m) * m / 2 > n + 1 {
        r = m;
    } else {
        l = m;
    }
}
${0:${VISUAL}}
endsnippet

snippet gcd "get GCD(Greatest Common Divisor)" b
let ${3:g} = gcd(${1:x}, ${2:y});
${0:${VISUAL}}
endsnippet

snippet lcm "get LCM(Least Common Multiple)" b
let ${3:l} = lcm(${1:x}, ${2:y});
${0:${VISUAL}}
endsnippet

snippet prm "get answer which is Prime Number or not" b
${0:${VISUAL}}
fn is_prime(x: usize) -> bool {
    if x < 2 {
        return false;
    }
    for i in 2..x {
        if i * i > x {
            return true;
        } else if x % i == 0 {
            return false;
        }
    }
    true
}
endsnippet

snippet prf "get answer of Prime Factorization" b
${0:${VISUAL}}
fn prime_fac(mut x: usize) -> HashSet<usize> {
    let mut pfs = HashSet::new();
    for i in 2..x {
        if i * i > x {
            break;
        }
        while x % i == 0 {
            pfs.insert(i);
            x /= i;
        }
    }
    pfs.insert(x);
    pfs.insert(1);
    pfs
}
endsnippet

snippet mod "use ModInt" b
let n = mod_int(n);
println!("{}", n.value());
${0:${VISUAL}}
use std::ops::{
    Add, AddAssign, BitAnd, Div, DivAssign, Mul, MulAssign, RemAssign, ShrAssign, Sub, SubAssign,
};

fn mod_int(v: ${1:usize}) -> ModInt<$1> {
    ModInt::new(v, ${2:1_000_000_007})
}
pub struct ModInt<T> {
    v: T,
    m: T,
}

impl<T> ModInt<T>
where
    T: Copy,
{
    pub fn value(&self) -> T {
        self.v
    }
    pub fn modulo(&self) -> T {
        self.m
    }
}

impl<T> ModInt<T> {
    fn new_unchecked(v: T, modulo: T) -> Self {
        Self { v, m: modulo }
    }
}

impl<T> ModInt<T>
where
    T: Copy + RemAssign + PartialOrd,
{
    pub fn new(mut v: T, modulo: T) -> Self {
        if v >= modulo {
            v %= modulo;
        }
        Self::new_unchecked(v, modulo)
    }
}

impl<T> ModInt<T>
where
    T: Copy
        + Sub<Output = T>
        + ShrAssign
        + BitAnd<Output = T>
        + PartialEq
        + PartialOrd
        + Div<Output = T>
        + RemAssign,
    ModInt<T>: MulAssign,
{
    pub fn pow(self, e: T) -> Self {
        let zero = self.modulo() - self.modulo();
        let one = self.modulo() / self.modulo();
        let mut e = e;
        let mut result = Self::new_unchecked(one, self.modulo());
        let mut cur = self;
        while e > zero {
            if e & one == one {
                result *= cur;
            }
            e >>= one;
            cur *= cur;
        }
        result
    }
}

impl<T> Copy for ModInt<T> where T: Copy {}
impl<T> Clone for ModInt<T>
where
    T: Copy,
{
    fn clone(&self) -> Self {
        Self::new_unchecked(self.value(), self.modulo())
    }
}

impl<T> Add<T> for ModInt<T>
where
    T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,
{
    type Output = Self;
    fn add(self, mut rhs: T) -> Self::Output {
        if rhs >= self.modulo() {
            rhs %= self.modulo();
        }
        rhs += self.value();
        if rhs >= self.modulo() {
            rhs -= self.modulo();
        }
        Self::new_unchecked(rhs, self.modulo())
    }
}

impl<T> Sub<T> for ModInt<T>
where
    T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,
{
    type Output = Self;
    fn sub(self, mut rhs: T) -> Self::Output {
        if rhs >= self.modulo() {
            rhs %= self.modulo();
        }

        let mut result = self.value();
        result += self.modulo();
        result -= rhs;

        if result >= self.modulo() {
            result -= self.modulo();
        }
        Self::new_unchecked(result, self.modulo())
    }
}

impl<T> Mul<T> for ModInt<T>
where
    T: MulAssign + RemAssign + Copy + PartialOrd,
{
    type Output = Self;
    fn mul(self, mut rhs: T) -> Self::Output {
        if rhs >= self.modulo() {
            rhs %= self.modulo();
        }
        rhs *= self.value();
        rhs %= self.modulo();
        Self::new_unchecked(rhs, self.modulo())
    }
}

impl<T> Add<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Add<T, Output = ModInt<T>>,
{
    type Output = Self;
    fn add(self, rhs: ModInt<T>) -> Self::Output {
        self + rhs.value()
    }
}
impl<T> Sub<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Sub<T, Output = ModInt<T>>,
{
    type Output = Self;
    fn sub(self, rhs: ModInt<T>) -> Self::Output {
        self - rhs.value()
    }
}
impl<T> Mul<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Mul<T, Output = ModInt<T>>,
{
    type Output = Self;
    fn mul(self, rhs: ModInt<T>) -> Self::Output {
        self * rhs.value()
    }
}
impl<T> Div<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Div<T, Output = ModInt<T>>,
{
    type Output = Self;
    fn div(self, rhs: ModInt<T>) -> Self::Output {
        self / rhs.value()
    }
}

impl<T> AddAssign<T> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Add<T, Output = ModInt<T>>,
{
    fn add_assign(&mut self, other: T) {
        *self = *self + other;
    }
}
impl<T> AddAssign<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Add<ModInt<T>, Output = ModInt<T>>,
{
    fn add_assign(&mut self, other: ModInt<T>) {
        *self = *self + other;
    }
}

impl<T> SubAssign<T> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Sub<T, Output = ModInt<T>>,
{
    fn sub_assign(&mut self, other: T) {
        *self = *self - other;
    }
}

impl<T> SubAssign<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Sub<ModInt<T>, Output = ModInt<T>>,
{
    fn sub_assign(&mut self, other: ModInt<T>) {
        *self = *self - other;
    }
}

impl<T> DivAssign<T> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Div<T, Output = ModInt<T>>,
{
    fn div_assign(&mut self, rhs: T) {
        *self = *self / rhs
    }
}
impl<T> DivAssign<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Div<ModInt<T>, Output = ModInt<T>>,
{
    fn div_assign(&mut self, rhs: ModInt<T>) {
        *self = *self / rhs
    }
}

impl<T> MulAssign<T> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Mul<T, Output = ModInt<T>>,
{
    fn mul_assign(&mut self, rhs: T) {
        *self = *self * rhs;
    }
}

impl<T> MulAssign<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Mul<ModInt<T>, Output = ModInt<T>>,
{
    fn mul_assign(&mut self, rhs: ModInt<T>) {
        *self = *self * rhs;
    }
}

impl<T> Div<T> for ModInt<T>
where
    T: Copy
        + Add<Output = T>
        + Sub<Output = T>
        + Div<Output = T>
        + BitAnd<Output = T>
        + PartialEq
        + PartialOrd
        + ShrAssign
        + RemAssign
        + MulAssign,
{
    type Output = Self;
    fn div(self, mut rhs: T) -> Self::Output {
        if rhs >= self.modulo() {
            rhs %= self.modulo();
        }
        let one = self.modulo() / self.modulo();
        let two = one + one;
        self * Self::new_unchecked(rhs, self.modulo()).pow(self.modulo() - two)
    }
}
endsnippet

snippet forb "for loop and bit full search" b
for ${2:i} in 0..(1 << ${1:k}) {
    let mut ext = vec![false; ${4:n}];
    for ${3:j} in 0..$1 {
        if $2 >> $3 & 1 == 1 {
            ext[cd[$3].0] = true;
        } else {
            ext[cd[$3].1] = true;
        }
    }

    let mut sum = 0;
    for &(a, b) in &ab {
        if ext[a] && ext[b] {
            sum += 1;
        }
    }
    ans = max(ans, sum);
}
${0:${VISUAL}}
endsnippet

snippet que "queue by VecDeque" b
let mut qu = VecDeque::new();
qu.push_back(1);
qu.push_back(2);
qu.push_back(3);
while let Some(v) = qu.pop_front() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet sta "stack by VecDeque" b
let mut st = VecDeque::new();
st.push_back(1);
st.push_back(2);
st.push_back(3);
while let Some(v) = st.pop_back() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet pqmax "use priority queue(implemented with a binary heap) in collections(pop by max)" b
let mut pq = BinaryHeap::new();
pq.push(1);
pq.push(3);
pq.push(2);
while let Some(v) = pq.pop() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet pqmin "use priority queue(implemented with a binary heap) in collections(pop by min)" b
let mut pq = BinaryHeap::new();
pq.push(Reverse(1));
pq.push(Reverse(3));
pq.push(Reverse(2));
while let Some(v) = pq.pop() {
    println!("{}", v.0);
}
${0:${VISUAL}}
endsnippet

snippet sin "sin(...)" b
let ${1:x} = (PI / 2f64).sin();
${0:${VISUAL}}
endsnippet

snippet cos "math.cos(...)" b
let ${1:x} = (PI / 2f64).cos();
${0:${VISUAL}}
endsnippet

snippet fac "get factorial value" b
let ${2:f} = (2..=${1:n}).fold(1, |acc, x| acc * x);
${0:${VISUAL}}
endsnippet

snippet fib "get fibonacci value" b
${0:${VISUAL}}
fn fib(x: usize) -> usize {
    let (mut a, mut b) = (0, 1);
    for _ in 0..x {
        let t = a + b;
        b = a;
        a = t;
    }
    a
}
endsnippet

snippet per "get permutation" b
let p = (0..${1:n}).permutations(${2:k}).collect::<Vec<Vec<${3:usize}>>>();
println!("{}", p.len());
${0:${VISUAL}}
endsnippet

snippet cmb "get combination" b
let c = (0..${1:n}).combinations(${2:k}).collect::<Vec<Vec<${3:usize}>>>();
println!("{}", c.len());
${0:${VISUAL}}
endsnippet

snippet cmbr "get combination with replacement" b
let c = (0..${1:n})
    .combinations_with_replacement(${2:k})
    .collect::<Vec<Vec<${3:usize}>>>();
println!("{}", c.len());
${0:${VISUAL}}
endsnippet

snippet gr "Data structure for graph"
let mut g = vec![vec![]; n];
for (a, b) in ab {
    g[a].push(b);
    g[b].push(a);
}
${0:${VISUAL}}
endsnippet

snippet dfs "Depth First Search in graph"
let mut st = VecDeque::new();
st.push_back(0);
let mut seen = HashSet::new();
seen.insert(0);
while let Some(v) = st.pop_back() {
    for &nx in &g[v] {
        if seen.contains(&nx) {
            continue;
        }
        st.push_back(nx);
        seen.insert(nx);
    }
}
${0:${VISUAL}}
endsnippet

snippet bfs "Breadth First Search in graph"
let mut qu = VecDeque::new();
qu.push_back(0);
let mut seen = HashSet::new();
seen.insert(0);
while let Some(v) = qu.pop_front() {
    for &nx in &g[v] {
        if seen.contains(&nx) {
            continue;
        }
        qu.push_back(nx);
        seen.insert(nx);
    }
}
${0:${VISUAL}}
endsnippet

snippet di "Dijkstra's algorithm"
const INF: usize = std::usize::MAX;
let mut ds = vec![INF; n];
ds[x] = 0;
let mut pq = BinaryHeap::new();
pq.push((Reverse(0), x));
while let Some((Reverse(d), v)) = pq.pop() {
    if d > ds[v] {
        continue;
    }
    for &(nx, c) in &g[v] {
        if d + c < ds[nx] {
            ds[nx] = d + c;
            pq.push((Reverse(ds[nx]), nx));
        }
    }
}
${0:${VISUAL}}
endsnippet

snippet uft "union find tree" b
let mut uft = unionfind::UnionFind::new(n);
for (a, b) in ab {
    uft.union(a, b);
}

let mut size = HashMap::new();
for i in 0..n {
    *size.entry(uft.find(i)).or_insert(0) += 1;
}
${0:${VISUAL}}
endsnippet

snippet war "Warshall Floyd Algorithm"
let mut ds = vec![vec![1_000_000_000; ${1:n}]; $1];
for i in 0..$1 {
    ds[i][i] = 0;
}
for (a, b, w) in ab {
    ds[a][b] = w;
    ds[b][a] = w;
}
for k in 0..${2:m} {
    for i in 0..$2 {
        for j in 0..$2 {
            ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);
        }
    }
}

let mut ans = 1_000_000_000;
for i in 0..$1 {
    ans = min(ans, *ds[i].into_iter().max().unwrap());
}
${0:${VISUAL}}
endsnippet

snippet fen "fenwick tree(Binary Indexed Tree)" b
${0:${VISUAL}}
#[allow(unused)]
mod fenwick_tree {
    pub struct FenwickTree<T> {
        n: usize,
        data: Vec<T>,
        init: T,
    }

    impl<T: Copy + std::ops::AddAssign + std::ops::Sub<Output = T>> FenwickTree<T> {
        pub fn new(size: usize, init: T) -> FenwickTree<T> {
            FenwickTree {
                n: size + 1,
                data: vec![init; size + 1],
                init,
            }
        }

        pub fn add(&mut self, k: usize, value: T) {
            let mut x = k;
            while x < self.n {
                self.data[x] += value;
                x |= x + 1;
            }
        }

        pub fn sum(&self, l: usize, r: usize) -> T {
            self.sum_one(r) - self.sum_one(l)
        }

        pub fn sum_one(&self, k: usize) -> T {
            assert!(k < self.n, "k={} n={}", k, self.n);

            let mut result = self.init;
            let mut x = k as i32 - 1;
            while x >= 0 {
                result += self.data[x as usize];
                x = (x & (x + 1)) - 1;
            }

            result
        }
    }
}
endsnippet

snippet seg "Segment Tree" b
    let mut st = SegTree::new(n, |x, y| x ^ y, 0);
    for i in 0..n {
        st.update(i, a[i]);
    }
    for (t, x, y) in txy {
        if t == 1 {
            st.update(x, (st.query(x, x + 1)) ^ y);
        } else {
            println!("{}", st.query(x, y));
        }
    }

${0:${VISUAL}}
#[allow(unused)]
struct SegTree<I, BiOp> {
    n: usize,
    dat: Vec<I>,
    op: BiOp,
    e: I,
}

impl<I, BiOp> SegTree<I, BiOp>
where
    BiOp: Fn(I, I) -> I,
    I: Copy,
{
    pub fn new(n_: usize, op: BiOp, e: I) -> Self {
        let mut n = 1;
        while n < n_ {
            n *= 2;
        }
        SegTree {
            n: n,
            dat: vec![e; 2 * n - 1],
            op: op,
            e: e,
        }
    }

    pub fn update(&mut self, idx: usize, v: I) {
        let mut k = idx + self.n - 1;
        self.dat[k] = v;
        while k > 0 {
            k = (k - 1) / 2;
            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);
        }
    }

    pub fn query(&self, mut a: usize, mut b: usize) -> I {
        let mut left = self.e;
        let mut right = self.e;
        a += self.n - 1;
        b += self.n - 1;
        while a < b {
            if (a & 1) == 0 {
                left = (self.op)(left, self.dat[a]);
            }
            if (b & 1) == 0 {
                right = (self.op)(self.dat[b - 1], right);
            }
            a = a / 2;
            b = (b - 1) / 2;
        }
        (self.op)(left, right)
    }
}
endsnippet

# vim:ft=snippets:
