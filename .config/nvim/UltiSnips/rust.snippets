priority 0

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header

snippet rt "return" b
return${1:};
${0:${VISUAL}}
endsnippet

snippet br "break" b
break;
endsnippet

snippet cn "continue" b
continue;
endsnippet

snippet ans "variable for answer" b
let mut ans = 0;
${0:${VISUAL}}
println!("{}", ans);
endsnippet

snippet pt "println!"
println!("${1:{}}", ${2:n});
endsnippet

snippet cond "conditional operator"
if ${1:n < 0} { ${2:0} } else { ${3:1} }
endsnippet
 
snippet for "for ... in ..." b
for ${1:v} in ${2:a} {
    ${0:${VISUAL}}
}
endsnippet

snippet forr "reverse for ... in ..." b
for ${1:v} in ${2:a}.into_iter().rev() {
    ${0:${VISUAL}}
}
endsnippet

snippet fore "for ... in ....into_iter().enumerate()" b
for (${1:i}, ${2:v}) in ${3:a}.into_iter().enumerate() {
    ${0:${VISUAL}}
}
endsnippet

snippet forer "for ... in ....into_iter().rev().enumerate()" b
for (${1:i}, ${2:v}) in ${3:a}.into_iter().rev().enumerate() {
    ${0:${VISUAL}}
}
endsnippet

snippet wh "while" b
let mut ${1:n} = $1;
while ${2:n > 0} {
    ${0:${VISUAL}}
}
endsnippet

snippet pars "parse String to number"
${1:s}.parse::<${2:usize}>().unwrap())${0:${VISUAL}}
endsnippet

snippet ston "same as 'pars', parse String to number"
${1:s}.parse::<${2:usize}>().unwrap())${0:${VISUAL}}
endsnippet

snippet ctos "parse Vec<char> to String"
${1:s}.into_iter().collect::<String>()
endsnippet

snippet con "concat String"
[${1:s}, ${2:t}].concat()${0:${VISUAL}}
endsnippet

snippet join "Same as 'concat', concat String"
[${1:s}, ${2:t}].concat()${0:${VISUAL}}
endsnippet

snippet revs "reverse string"
${1:s}.into_iter().rev().collect::<String>()${0:${VISUAL}}
endsnippet

snippet imax "get max value from Iterator"
${1:a}.into_iter().max().unwrap()
endsnippet

snippet imaxm "get max value from multiple Iterator"
${1:a}.into_iter().map(|x| x.into_iter().max().unwrap()).max().unwrap()
endsnippet

snippet imin "get min value from Iterator"
${1:a}.into_iter().min().unwrap()
endsnippet

snippet iminm "get min value from multiple Iterator"
${1:a}.into_iter().map(|x| x.into_iter().min().unwrap()).min().unwrap()
endsnippet

snippet iind "get index from Iterator"
${1:a}.into_iter().position(|x| x == ${2:v}).unwrap()
endsnippet

snippet ipos "Same as iindex, get index from Iterator"
${1:a}.into_iter().position(|x| x == ${2:v}).unwrap()
endsnippet

snippet hmaxk "get max key from HashMap"
${1:hm}.into_iter().max_by_key(|x| x.1).unwrap().0
endsnippet

snippet hmaxv "get max value from HashMap"
${1:hm}.values().max().unwrap()
endsnippet

snippet hmink "get min key from HashMap"
${1:hm}.into_iter().min_by_key(|x| x.1).unwrap().0
endsnippet

snippet hminv "get min value from HashMap"
${1:hm}.values().min().unwrap()
endsnippet

snippet hcou "count in HashMap" b
*${1:hm}.entry(k).or_insert(0) += 1;
endsnippet

snippet fold "An iterator method that applies a function, producing a single, final value."
${1:a}.iter().fold($1[0], |acc, &x| gcd(acc, x))${0:${VISUAL}}
endsnippet

snippet reduce "Same as 'fold', An iterator method that applies a function, producing a single, final value."
${1:a}.iter().fold($1[0], |acc, &x| gcd(acc, x))${0:${VISUAL}}
endsnippet

snippet map "map function"
let ${1:b}: Vec<${2:usize}> = ${3:a}.into_iter().map(|x| x * 2).collect();
${0:${VISUAL}}
endsnippet

snippet fil "filter function"
let ${1:b}: Vec<${2:usize}> = ${3:a}.into_iter().filter(|x| x % 2 == 0).collect();
${0:${VISUAL}}
endsnippet

snippet sum "get sum value"
${1:a}.into_iter().sum::<${2:usize}>()${0:${VISUAL}}
endsnippet

snippet sumf "get sum value by fold"
${1:a}.into_iter().fold(0, |acc, x| acc + x)${0:${VISUAL}}
endsnippet

snippet csum "get cumulative sum" b
let csum = ${1:a}.into_iter().cumsum().collect::<Vec<${2:usize}>>();
endsnippet

snippet csumz "get cumulative sum with inserting zero" b
let csum = std::iter::once(&0)
    .chain(&${1:a})
    .cumsum()
    .collect::<Vec<${2:usize}>>();
endsnippet

snippet sort "sort Vector" b
let mut ${1:a} = $1;
$1.sort();
${0:${VISUAL}}
endsnippet

snippet sortr "sort Vector reversely" b
let mut ${1:a} = $1;
$1.sort_by(|a, b| b.cmp(a));
${0:${VISUAL}}
endsnippet

snippet sortf "sort Vector with function" b
let mut ${1:ab} = $1;
$1.sort_by(|a, b| (&a.1).cmp(&b.1));
${0:${VISUAL}}
endsnippet

snippet bis "binary search" b
let idx = ${1:a}.binary_search(&${2:x}).unwrap_or_else(|x| x);
${0:${VISUAL}}
endsnippet

snippet bism "binary search manually" b
let a = vec![1, 2, 5, 7, 10];
let x = 7;
let (mut l, mut r) = (0, a.len() - 1);
while l < r {
    let m = (l + r) / 2;
    if a[m] < x {
        l = m + 1;
    } else {
        r = m;
    }
}
println!("{}", l);
${0:${VISUAL}}
endsnippet

snippet gcd "get GCD(Greatest Common Divisor)" b
gcd(a, b)
${0:${VISUAL}}
endsnippet

snippet lcm "get LCM(Least Common Multiple)" b
lcm(a, b)
${0:${VISUAL}}
endsnippet

snippet prm "get answer which is Prime Number or not" b
${0:${VISUAL}}
fn is_prime(x: usize) -> bool {
    if x < 2 {
        return false;
    }
    for i in 2..x {
        if i * i > x {
            return true;
        } else if x % i == 0 {
            return false;
        }
    }
    true
}
endsnippet

snippet prf "get answer of Prime Factorization" b
${0:${VISUAL}}
fn prime_fac(mut x: usize) -> HashSet<usize> {
    let mut pfs = HashSet::new();
    for i in 2..x {
        if i * i > x {
            break;
        }
        while x % i == 0 {
            pfs.insert(i);
            x /= i;
        }
    }
    pfs.insert(x);
    pfs.insert(1);
    pfs
}
endsnippet

snippet mod "use ModInt" b
let n = mod_int(n);
println!("{}", n.value());
${0:${VISUAL}}
use std::ops::{
    Add, AddAssign, BitAnd, Div, DivAssign, Mul, MulAssign, RemAssign, ShrAssign, Sub, SubAssign,
};

fn mod_int(v: ${1:usize}) -> ModInt<$1> {
    ModInt::new(v, ${2:1_000_000_007})
}
pub struct ModInt<T> {
    v: T,
    m: T,
}

impl<T> ModInt<T>
where
    T: Copy,
{
    pub fn value(&self) -> T {
        self.v
    }
    pub fn modulo(&self) -> T {
        self.m
    }
}

impl<T> ModInt<T> {
    fn new_unchecked(v: T, modulo: T) -> Self {
        Self { v, m: modulo }
    }
}

impl<T> ModInt<T>
where
    T: Copy + RemAssign + PartialOrd,
{
    pub fn new(mut v: T, modulo: T) -> Self {
        if v >= modulo {
            v %= modulo;
        }
        Self::new_unchecked(v, modulo)
    }
}

impl<T> ModInt<T>
where
    T: Copy
        + Sub<Output = T>
        + ShrAssign
        + BitAnd<Output = T>
        + PartialEq
        + PartialOrd
        + Div<Output = T>
        + RemAssign,
    ModInt<T>: MulAssign,
{
    pub fn pow(self, e: T) -> Self {
        let zero = self.modulo() - self.modulo();
        let one = self.modulo() / self.modulo();
        let mut e = e;
        let mut result = Self::new_unchecked(one, self.modulo());
        let mut cur = self;
        while e > zero {
            if e & one == one {
                result *= cur;
            }
            e >>= one;
            cur *= cur;
        }
        result
    }
}

impl<T> Copy for ModInt<T> where T: Copy {}
impl<T> Clone for ModInt<T>
where
    T: Copy,
{
    fn clone(&self) -> Self {
        Self::new_unchecked(self.value(), self.modulo())
    }
}

impl<T> Add<T> for ModInt<T>
where
    T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,
{
    type Output = Self;
    fn add(self, mut rhs: T) -> Self::Output {
        if rhs >= self.modulo() {
            rhs %= self.modulo();
        }
        rhs += self.value();
        if rhs >= self.modulo() {
            rhs -= self.modulo();
        }
        Self::new_unchecked(rhs, self.modulo())
    }
}

impl<T> Sub<T> for ModInt<T>
where
    T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,
{
    type Output = Self;
    fn sub(self, mut rhs: T) -> Self::Output {
        if rhs >= self.modulo() {
            rhs %= self.modulo();
        }

        let mut result = self.value();
        result += self.modulo();
        result -= rhs;

        if result >= self.modulo() {
            result -= self.modulo();
        }
        Self::new_unchecked(result, self.modulo())
    }
}

impl<T> Mul<T> for ModInt<T>
where
    T: MulAssign + RemAssign + Copy + PartialOrd,
{
    type Output = Self;
    fn mul(self, mut rhs: T) -> Self::Output {
        if rhs >= self.modulo() {
            rhs %= self.modulo();
        }
        rhs *= self.value();
        rhs %= self.modulo();
        Self::new_unchecked(rhs, self.modulo())
    }
}

impl<T> Add<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Add<T, Output = ModInt<T>>,
{
    type Output = Self;
    fn add(self, rhs: ModInt<T>) -> Self::Output {
        self + rhs.value()
    }
}
impl<T> Sub<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Sub<T, Output = ModInt<T>>,
{
    type Output = Self;
    fn sub(self, rhs: ModInt<T>) -> Self::Output {
        self - rhs.value()
    }
}
impl<T> Mul<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Mul<T, Output = ModInt<T>>,
{
    type Output = Self;
    fn mul(self, rhs: ModInt<T>) -> Self::Output {
        self * rhs.value()
    }
}
impl<T> Div<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Div<T, Output = ModInt<T>>,
{
    type Output = Self;
    fn div(self, rhs: ModInt<T>) -> Self::Output {
        self / rhs.value()
    }
}

impl<T> AddAssign<T> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Add<T, Output = ModInt<T>>,
{
    fn add_assign(&mut self, other: T) {
        *self = *self + other;
    }
}
impl<T> AddAssign<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Add<ModInt<T>, Output = ModInt<T>>,
{
    fn add_assign(&mut self, other: ModInt<T>) {
        *self = *self + other;
    }
}

impl<T> SubAssign<T> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Sub<T, Output = ModInt<T>>,
{
    fn sub_assign(&mut self, other: T) {
        *self = *self - other;
    }
}

impl<T> SubAssign<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Sub<ModInt<T>, Output = ModInt<T>>,
{
    fn sub_assign(&mut self, other: ModInt<T>) {
        *self = *self - other;
    }
}

impl<T> DivAssign<T> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Div<T, Output = ModInt<T>>,
{
    fn div_assign(&mut self, rhs: T) {
        *self = *self / rhs
    }
}
impl<T> DivAssign<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Div<ModInt<T>, Output = ModInt<T>>,
{
    fn div_assign(&mut self, rhs: ModInt<T>) {
        *self = *self / rhs
    }
}

impl<T> MulAssign<T> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Mul<T, Output = ModInt<T>>,
{
    fn mul_assign(&mut self, rhs: T) {
        *self = *self * rhs;
    }
}

impl<T> MulAssign<ModInt<T>> for ModInt<T>
where
    T: Copy,
    ModInt<T>: Mul<ModInt<T>, Output = ModInt<T>>,
{
    fn mul_assign(&mut self, rhs: ModInt<T>) {
        *self = *self * rhs;
    }
}

impl<T> Div<T> for ModInt<T>
where
    T: Copy
        + Add<Output = T>
        + Sub<Output = T>
        + Div<Output = T>
        + BitAnd<Output = T>
        + PartialEq
        + PartialOrd
        + ShrAssign
        + RemAssign
        + MulAssign,
{
    type Output = Self;
    fn div(self, mut rhs: T) -> Self::Output {
        if rhs >= self.modulo() {
            rhs %= self.modulo();
        }
        let one = self.modulo() / self.modulo();
        let two = one + one;
        self * Self::new_unchecked(rhs, self.modulo()).pow(self.modulo() - two)
    }
}
endsnippet


snippet forb "for loop and bit full search" b
for ${2:i} in 0..2usize.pow(${1:n} as u32) {
    let mut hs = HashSet::new();
    for ${3:j} in 0..$1 {
        if $2 >> $3 & 1 == 1 {
            hs.insert($3);
        }
    }
    println!("{} {:?}", $2, hs);
}
${0:${VISUAL}}
endsnippet

snippet dq "use deque in collections" b
let mut dq = VecDeque::new();
dq.push_back(1);
dq.push_back(2);
dq.push_back(3);
while let Some(v) = dq.pop_front() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet st "use deque for stack in collections" b
let mut st = VecDeque::new();
st.push_back(1);
st.push_back(2);
st.push_back(3);
while let Some(v) = st.pop_back() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet pqmax "use priority queue(implemented with a binary heap) in collections(pop by max)" b
let mut pq = BinaryHeap::new();
pq.push(1);
pq.push(3);
pq.push(2);
while let Some(v) = pq.pop() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet pqmin "use priority queue(implemented with a binary heap) in collections(pop by min)" b
let mut pq = BinaryHeap::new();
pq.push(Reverse(1));
pq.push(Reverse(3));
pq.push(Reverse(2));
while let Some(v) = pq.pop() {
    println!("{}", v.0);
}
${0:${VISUAL}}
endsnippet

snippet sin "sin(...)" b
(PI / 2f64).sin()
${0:${VISUAL}}
endsnippet

snippet cos "math.cos(...)" b
(PI / 2f64).cos()
${0:${VISUAL}}
endsnippet

snippet fac "get factorial value" b
(2..=${1:n}).fold(1, |acc, x| acc * x)${0:${VISUAL}}
endsnippet

snippet fib "get fibonacci value" b
${0:${VISUAL}}
fn fib(x: usize) -> usize {
    let (mut a, mut b) = (0, 1);
    for _ in 0..x {
        let t = a + b;
        b = a;
        a = t;
    }
    a
}
endsnippet

snippet per "get permutation" b
let p = (0..${1:n}).permutations(${2:k}).collect::<Vec<Vec<${3:usize}>>>();
println!("{}", p.len());
${0:${VISUAL}}
endsnippet

snippet cmb "get combination" b
let c = (0..${1:n}).combinations(${2:k}).collect::<Vec<Vec<${3:usize}>>>();
println!("{}", c.len());
${0:${VISUAL}}
endsnippet

snippet cmbr "get combination with replacement" b
let c = (0..${1:n})
    .combinations_with_replacement(${2:k})
    .collect::<Vec<Vec<${3:usize}>>>();
println!("{}", c.len());
${0:${VISUAL}}
endsnippet

snippet gr "Data structure for graph"
let mut g = vec![vec![]; n];
for (a, b) in ab {
    g[a].push(b);
    g[b].push(a);
}
${0:${VISUAL}}
endsnippet

snippet dfs "Depth First Search in graph"
let mut st = VecDeque::new();
st.push_back(0);
let mut seen = HashSet::new();
seen.insert(0);
while let Some(v) = st.pop_back() {
    for nx in g[v].iter() {
        if seen.contains(nx) {
            continue;
        }
        st.push_back(*nx);
        seen.insert(*nx);
    }
}
${0:${VISUAL}}
endsnippet

snippet bfs "Breadth First Search in graph"
let mut dq = VecDeque::new();
dq.push_back(0);
let mut seen = HashSet::new();
seen.insert(0);
while let Some(v) = dq.pop_front() {
    for nx in g[v].iter() {
        if seen.contains(nx) {
            continue;
        }
        dq.push_back(*nx);
        seen.insert(*nx);
    }
}
${0:${VISUAL}}
endsnippet

snippet uft "union find tree" b
let mut uft = unionfind::UnionFind::new(n);
for (a, b) in ab {
    uft.union(a, b);
}

let mut size = HashMap::new();
for i in 0..n {
    *size.entry(uft.find(i)).or_insert(0) += 1;
}
${0:${VISUAL}}
endsnippet

snippet war "Warshall Floyd Algorithm"
let mut ds = vec![vec![1_000_000_000; ${1:n}]; $1];
for i in 0..$1 {
    ds[i][i] = 0;
}
for (a, b, w) in ab {
    ds[a][b] = w;
    ds[b][a] = w;
}
for k in 0..${2:m} {
    for i in 0..$2 {
        for j in 0..$2 {
            ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);
        }
    }
}

let mut ans = 1_000_000_000;
for i in 0..$1 {
    ans = min(ans, *ds[i].into_iter().max().unwrap());
}
${0:${VISUAL}}
endsnippet

snippet fen "fenwick tree(Binary Indexed Tree)" b
${0:${VISUAL}}
#[allow(unused)]
mod fenwick_tree {
    pub struct FenwickTree<T> {
        n: usize,
        data: Vec<T>,
        init: T,
    }

    impl<T: Copy + std::ops::AddAssign + std::ops::Sub<Output = T>> FenwickTree<T> {
        pub fn new(size: usize, init: T) -> FenwickTree<T> {
            FenwickTree {
                n: size + 1,
                data: vec![init; size + 1],
                init,
            }
        }

        pub fn add(&mut self, k: usize, value: T) {
            let mut x = k;
            while x < self.n {
                self.data[x] += value;
                x |= x + 1;
            }
        }

        pub fn sum(&self, l: usize, r: usize) -> T {
            self.sum_one(r) - self.sum_one(l)
        }

        pub fn sum_one(&self, k: usize) -> T {
            assert!(k < self.n, "k={} n={}", k, self.n);

            let mut result = self.init;
            let mut x = k as i32 - 1;
            while x >= 0 {
                result += self.data[x as usize];
                x = (x & (x + 1)) - 1;
            }

            result
        }
    }
}
endsnippet

snippet seg "Segment Tree" b
    let mut st = SegTree::new(n, |x, y| x ^ y, 0);
    for i in 0..n {
        st.update(i, a[i]);
    }
    for (t, x, y) in txy {
        if t == 1 {
            st.update(x, (st.query(x, x + 1)) ^ y);
        } else {
            println!("{}", st.query(x, y));
        }
    }

${0:${VISUAL}}
#[allow(unused)]
struct SegTree<I, BiOp> {
    n: usize,
    dat: Vec<I>,
    op: BiOp,
    e: I,
}

impl<I, BiOp> SegTree<I, BiOp>
where
    BiOp: Fn(I, I) -> I,
    I: Copy,
{
    pub fn new(n_: usize, op: BiOp, e: I) -> Self {
        let mut n = 1;
        while n < n_ {
            n *= 2;
        }
        SegTree {
            n: n,
            dat: vec![e; 2 * n - 1],
            op: op,
            e: e,
        }
    }

    pub fn update(&mut self, idx: usize, v: I) {
        let mut k = idx + self.n - 1;
        self.dat[k] = v;
        while k > 0 {
            k = (k - 1) / 2;
            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);
        }
    }

    pub fn query(&self, mut a: usize, mut b: usize) -> I {
        let mut left = self.e;
        let mut right = self.e;
        a += self.n - 1;
        b += self.n - 1;
        while a < b {
            if (a & 1) == 0 {
                left = (self.op)(left, self.dat[a]);
            }
            if (b & 1) == 0 {
                right = (self.op)(self.dat[b - 1], right);
            }
            a = a / 2;
            b = (b - 1) / 2;
        }
        (self.op)(left, right)
    }
}
endsnippet

# vim:ft=snippets:
