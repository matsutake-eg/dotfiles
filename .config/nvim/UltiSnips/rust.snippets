priority 0

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header

snippet rt "return" b
return${1:};
${0:${VISUAL}}
endsnippet

snippet br "break" b
break;
endsnippet

snippet cn "continue" b
continue;
endsnippet

snippet ans "variable for answer" b
let mut ans = 0;
${0:${VISUAL}}
println!("{}", ans);
endsnippet

snippet pt "println!"
println!("${1:{}}", ${2:n});
endsnippet

snippet cond "conditional operator"
if ${1:n < 0} { ${2:0} } else { ${3:1} }
endsnippet
 
snippet for "for ... in ..." b
for ${1:v} in ${2:a} {
    ${0:${VISUAL}}
}
endsnippet

snippet forr "reverse for ... in ..." b
for ${1:v} in ${2:a}.iter().rev() {
    ${0:${VISUAL}}
}
endsnippet

snippet fore "for ... in ....iter().enumerate()" b
for (${1:i}, ${2:v}) in ${3:a}.iter().enumerate() {
    ${0:${VISUAL}}
}
endsnippet

snippet forer "for ... in ....iter().rev().enumerate()" b
for (${1:i}, ${2:v}) in ${3:a}.iter().rev().enumerate() {
    ${0:${VISUAL}}
}
endsnippet

snippet wh "while" b
let mut ${1:n} = $1;
while ${2:n > 0} {
    ${0:${VISUAL}}
}
endsnippet

snippet pars "parse String to number"
${1:s}.parse::<${2:usize}>().unwrap())${0:${VISUAL}}
endsnippet

snippet ston "same as 'pars', parse String to number"
${1:s}.parse::<${2:usize}>().unwrap())${0:${VISUAL}}
endsnippet

snippet con "concat String"
[${1:s}, ${2:t}].concat()${0:${VISUAL}}
endsnippet

snippet join "Same as 'concat', concat String"
[${1:s}, ${2:t}].concat()${0:${VISUAL}}
endsnippet

snippet revs "reverse string"
${1:s}.iter().rev().collect::<String>()${0:${VISUAL}}
endsnippet

snippet vmax "get max value from Vector"
${1:a}.iter().max().unwrap()
endsnippet

snippet vmin "get min value from Vector"
${1:a}.iter().min().unwrap()
endsnippet

snippet hmax "get max element from HashMap"
${1:hm}.iter().max_by_key(|x| x.1).unwrap().0
endsnippet

snippet hmaxv "get max value from HashMap"
${1:hm}.values().max().unwrap()
endsnippet

snippet hmin "get min element from HashMap"
${1:hm}.iter().min_by_key(|x| x.1).unwrap().0
endsnippet

snippet hminv "get min value from HashMap"
${1:hm}.values().min().unwrap()
endsnippet

snippet hcou "count in HashMap" b
*${1:hm}.entry(k).or_insert(0) += 1;
endsnippet

snippet fold "An iterator method that applies a function, producing a single, final value."
${1:a}.iter().fold($1[0], |acc, &x| gcd(acc, x))${0:${VISUAL}}
endsnippet

snippet reduce "Same as 'fold', An iterator method that applies a function, producing a single, final value."
${1:a}.iter().fold($1[0], |acc, &x| gcd(acc, x))${0:${VISUAL}}
endsnippet

snippet map "map function"
let ${1:b}: Vec<${2:usize}> = ${3:a}.iter().map(|x| x * 2).collect();
${0:${VISUAL}}
endsnippet

snippet fil "filter function"
let ${1:b}: Vec<${2:usize}> = ${3:a}.iter().cloned().filter(|&x| x % 2 == 0).collect();
${0:${VISUAL}}
endsnippet

snippet sum "get sum value"
${1:a}.iter().sum::<${2:usize}>()${0:${VISUAL}}
endsnippet

snippet sumf "get sum value by fold"
${1:a}.iter().fold(0, |acc, x| acc + x)${0:${VISUAL}}
endsnippet

snippet csum "get cumulative sum" b
let csum = ${1:a}.iter().cumsum().collect::<Vec<${2:usize}>>();
endsnippet

snippet csumz "get cumulative sum with inserting zero" b
let csum = std::iter::once(&0)
    .chain(&${1:a})
    .cumsum()
    .collect::<Vec<${2:usize}>>();
endsnippet

snippet pow "get value to the power of exp"
${1:a}.pow(${2:b} as u32)${0:${VISUAL}}
endsnippet

snippet sort "sort Vector" b
let mut ${1:a} = $1;
$1.sort();
${0:${VISUAL}}
endsnippet

snippet sortr "sort Vector reversely" b
let mut ${1:a} = $1;
$1.sort_by(|a, b| b.cmp(a));
${0:${VISUAL}}
endsnippet

snippet sortf "sort Vector with function" b
let mut ${1:ab} = $1;
$1.sort_by(|a, b| (&a.1).cmp(&b.1));
${0:${VISUAL}}
endsnippet

snippet bis "binary search" b
let idx = ${1:a}.binary_search(&${2:x}).unwrap_or_else(|x| x);
${0:${VISUAL}}
endsnippet

snippet bism "binary search manually" b
let a = vec![1, 2, 5, 7, 10];
let x = 7;
let (mut l, mut r) = (0, a.len() - 1);
while l < r {
    let m = (l + r) / 2;
    if a[m] < x {
        l = m + 1;
    } else {
        r = m;
    }
}
println!("{}", l);
${0:${VISUAL}}
endsnippet

snippet gcd "get GCD(Greatest Common Divisor)" b
gcd(a, b)
${0:${VISUAL}}
endsnippet

snippet lcm "get LCM(Least Common Multiple)" b
lcm(a, b)
${0:${VISUAL}}
endsnippet

snippet prm "get answer which is Prime Number or not" b
${0:${VISUAL}}
fn is_prime(x: usize) -> bool {
    if x < 2 {
        return false;
    }
    for i in 2..x {
        if i * i > x {
            return true;
        } else if x % i == 0 {
            return false;
        }
    }
    true
}
endsnippet

snippet prf "get answer of Prime Factorization" b
${0:${VISUAL}}
fn prime_fac(mut x: usize) -> HashSet<usize> {
    let mut pfs = HashSet::new();
    for i in 2..x {
        if i * i > x {
            break;
        }
        while x % i == 0 {
            pfs.insert(i);
            x /= i;
        }
    }
    pfs.insert(x);
    pfs.insert(1);
    pfs
}
endsnippet

snippet forb "for loop and bit full search" b
for ${2:i} in 0..2usize.pow(${1:n} as u32) {
    let mut hs = HashSet::new();
    for ${3:j} in 0..$1 {
        if $2 >> $3 & 1 == 1 {
            hs.insert($3);
        }
    }
    println!("{} {:?}", $2, hs);
}
${0:${VISUAL}}
endsnippet

snippet dq "use deque in collections" b
let mut dq = VecDeque::new();
dq.push_back(1);
dq.push_back(2);
dq.push_back(3);
while let Some(v) = dq.pop_front() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet st "use deque for stack in collections" b
let mut st = VecDeque::new();
st.push_back(1);
st.push_back(2);
st.push_back(3);
while let Some(v) = st.pop_back() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet pqmax "use priority queue(implemented with a binary heap) in collections(pop by max)" b
let mut pq = BinaryHeap::new();
pq.push(1);
pq.push(3);
pq.push(2);
while let Some(v) = pq.pop() {
    println!("{}", v);
}
${0:${VISUAL}}
endsnippet

snippet pqmin "use priority queue(implemented with a binary heap) in collections(pop by min)" b
let mut pq = BinaryHeap::new();
pq.push(Reverse(1));
pq.push(Reverse(3));
pq.push(Reverse(2));
while let Some(v) = pq.pop() {
    println!("{}", v.0);
}
${0:${VISUAL}}
endsnippet

snippet sin "sin(...)" b
(PI / 2f64).sin()
${0:${VISUAL}}
endsnippet

snippet cos "math.cos(...)" b
(PI / 2f64).cos()
${0:${VISUAL}}
endsnippet

snippet fac "get factorial value" b
(2..=${1:n}).fold(1, |acc, x| acc * x)${0:${VISUAL}}
endsnippet

snippet facm "get factorial value with mod" b
(2..=${1:n}).fold(1, |acc, x| acc * x % MOD)${0:${VISUAL}}
endsnippet

snippet fib "get fibonacci value" b
${0:${VISUAL}}
fn fib(x: usize) -> usize {
    let (mut a, mut b) = (0, 1);
    for _ in 0..x {
        let t = a + b;
        b = a;
        a = t;
    }
    a
}
endsnippet

snippet powm "get x**y the base-x exponential of y by mod"
${0:${VISUAL}}
fn powm(x: usize, y: usize) -> usize {
    if y == 0 {
        return 1;
    } else if y % 2 == 0 {
        let x = powm(x, y / 2);
        return x * x % MOD;
    }
    x * powm(x, y - 1) % MOD
}
endsnippet

snippet inv "inverse" b
powm(${1:n}, ${2:p} - 2, $2)
${0:${VISUAL}}

fn powm(x: usize, y: usize, z: usize) -> usize {
    if y == 0 {
        return 1;
    } else if y % 2 == 0 {
        let x = powm(x, y / 2, z);
        return x * x % z;
    }
    x * powm(x, y - 1, z) % z
}
endsnippet

snippet per "get permutation" b
let p = (0..${1:n}).permutations(${2:k}).collect::<Vec<Vec<${3:usize}>>>();
println!("{}", p.len());
${0:${VISUAL}}
endsnippet

snippet perm "get permutation value with mod" b
${0:${VISUAL}}
fn permutations_mod(n: usize, k: usize) -> usize {
    let mut x = 1;
    for i in (n - k + 1)..=n {
        x = x * i % MOD;
    }
    x
}
endsnippet

snippet cmb "get combination" b
let c = (0..${1:n}).combinations(${2:k}).collect::<Vec<Vec<${3:usize}>>>();
println!("{}", c.len());
${0:${VISUAL}}
endsnippet

snippet cmbr "get combination with replacement" b
let c = (0..${1:n})
    .combinations_with_replacement(${2:k})
    .collect::<Vec<Vec<${3:usize}>>>();
println!("{}", c.len());
${0:${VISUAL}}
endsnippet

snippet cmbm "get combination value with mod" b
${0:${VISUAL}}
fn combinations_mod(n: usize, k: usize) -> usize {
    if k > n {
        return 1;
    }

    let (mut nu, mut de) = (1, 1);
    for i in 0..k {
        nu = nu * (n - i) % MOD;
        de = de * (i + 1) % MOD;
    }
    nu * powm(de, MOD - 2) % MOD
}

fn powm(x: usize, y: usize) -> usize {
    if y == 0 {
        return 1;
    } else if y % 2 == 0 {
        let x = powm(x, y / 2);
        return x * x % MOD;
    }
    x * powm(x, y - 1) % MOD
}
endsnippet

snippet gr "Data structure for graph"
let mut g = vec![vec![]; n];
for (a, b) in ab {
    g[a].push(b);
    g[b].push(a);
}
${0:${VISUAL}}
endsnippet

snippet dfs "Depth First Search in graph"
let mut st = VecDeque::new();
st.push_back(0);
let mut seen = HashSet::new();
seen.insert(0);
while let Some(v) = st.pop_back() {
    for nx in g[v].iter() {
        if seen.contains(nx) {
            continue;
        }
        st.push_back(*nx);
        seen.insert(*nx);
    }
}
${0:${VISUAL}}
endsnippet

snippet bfs "Breadth First Search in graph"
let mut dq = VecDeque::new();
dq.push_back(0);
let mut seen = HashSet::new();
seen.insert(0);
while let Some(v) = dq.pop_front() {
    for nx in g[v].iter() {
        if seen.contains(nx) {
            continue;
        }
        dq.push_back(*nx);
        seen.insert(*nx);
    }
}
${0:${VISUAL}}
endsnippet

snippet uft "union find tree" b
let mut uft = unionfind::UnionFind::new(n);
for (a, b) in ab {
    uft.union(a, b);
}

let mut size = HashMap::new();
for i in 0..n {
    *size.entry(uft.find(i)).or_insert(0) += 1;
}
${0:${VISUAL}}
endsnippet

snippet war "Warshall Floyd Algorithm"
let mut ds = vec![vec![1_000_000_000; ${1:n}]; $1];
for i in 0..$1 {
    ds[i][i] = 0;
}
for (a, b, w) in ab {
    ds[a][b] = w;
    ds[b][a] = w;
}
for k in 0..${2:m} {
    for i in 0..$2 {
        for j in 0..$2 {
            ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);
        }
    }
}

let mut ans = 1_000_000_000;
for i in 0..$1 {
    ans = min(ans, *ds[i].iter().max().unwrap());
}
${0:${VISUAL}}
endsnippet

snippet fen "fenwick tree(Binary Indexed Tree)" b
${0:${VISUAL}}
#[allow(unused)]
mod fenwick_tree {
    /// `FenwickTree` is a data structure that can efficiently update elements
    /// and calculate prefix sums in a table of numbers.
    /// [https://en.wikipedia.org/wiki/Fenwick_tree](https://en.wikipedia.org/wiki/Fenwick_tree)
    pub struct FenwickTree<T> {
        n: usize,
        data: Vec<T>,
        init: T,
    }

    impl<T: Copy + std::ops::AddAssign + std::ops::Sub<Output = T>> FenwickTree<T> {
        /// Constructs a new `FenwickTree`. The size of `FenwickTree` should be specified by `size`.
        pub fn new(size: usize, init: T) -> FenwickTree<T> {
            FenwickTree {
                n: size + 1,
                data: vec![init; size + 1],
                init,
            }
        }

        pub fn add(&mut self, k: usize, value: T) {
            let mut x = k;
            while x < self.n {
                self.data[x] += value;
                x |= x + 1;
            }
        }

        /// Returns a sum of range `[l, r)`
        pub fn sum(&self, l: usize, r: usize) -> T {
            self.sum_one(r) - self.sum_one(l)
        }

        /// Returns a sum of range `[0, k)`
        pub fn sum_one(&self, k: usize) -> T {
            assert!(k < self.n, "k={} n={}", k, self.n);

            let mut result = self.init;
            let mut x = k as i32 - 1;
            while x >= 0 {
                result += self.data[x as usize];
                x = (x & (x + 1)) - 1;
            }

            result
        }
    }
}

pub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);

impl<R: std::io::Read, W: std::io::Write> IO<R, W> {
    pub fn new(r: R, w: W) -> Self {
        Self(r, std::io::BufWriter::new(w))
    }
    pub fn write<S: ToString>(&mut self, s: S) {
        use std::io::Write;
        self.1.write_all(s.to_string().as_bytes()).unwrap();
    }
    pub fn read<T: std::str::FromStr>(&mut self) -> T {
        use std::io::Read;
        let buf = self
            .0
            .by_ref()
            .bytes()
            .map(|b| b.unwrap())
            .skip_while(|&b| b == b' ' || b == b'\n' || b == b'\r' || b == b'\t')
            .take_while(|&b| b != b' ' && b != b'\n' && b != b'\r' && b != b'\t')
            .collect::<Vec<_>>();
        unsafe { std::str::from_utf8_unchecked(&buf) }
            .parse()
            .ok()
            .expect("Parse error.")
    }
    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {
        (0..n).map(|_| self.read()).collect()
    }
    pub fn chars(&mut self) -> Vec<char> {
        self.read::<String>().chars().collect()
    }
}
endsnippet

# vim:ft=snippets:
