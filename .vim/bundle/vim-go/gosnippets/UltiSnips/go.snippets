# Snippets for Go

priority -10

snippet mod "a prime number used many times in programing contest"
const mod = 1000000007
${0:${VISUAL}}
endsnippet

snippet az "string which is a to z"
az := "abcdefghijklmnopqrstuvwxyz"
${0:${VISUAL}}
endsnippet

snippet maxi "max value of int(int64)"
ans := math.MaxInt64
${0:${VISUAL}}
endsnippet

snippet mini "min value of int(int64)"
ans := math.MinInt64
${0:${VISUAL}}
endsnippet

snippet maxf "max value of float(float64)"
ans := math.MaxFloat64
${0:${VISUAL}}
endsnippet

snippet minf "min value of float(float64)"
ans := math.SmallestNonzeroFloat64
${0:${VISUAL}}
endsnippet

snippet fs "fmt.Scan(...)"
fmt.Scan(&${1:n})
${0:${VISUAL}}
endsnippet

snippet fs1 "make variable and use fmt.Scan(...)"
var ${1:n} int
fmt.Scan(&$1)
${0:${VISUAL}}
endsnippet

snippet fs2 "make two variables and use fmt.Scan(...)"
var ${1:a}, ${2:b} int
fmt.Scan(&$1, &$2)
${0:${VISUAL}}
endsnippet

snippet fs3 "make three variables and use fmt.Scan(...)"
var ${1:a}, ${2:b}, ${3:c} int
fmt.Scan(&$1, &$2, &$3)
${0:${VISUAL}}
endsnippet

snippet fs4 "make four variables and use fmt.Scan(...)"
var ${1:a}, ${2:b}, ${3:c}, ${4:d} int
fmt.Scan(&$1, &$2, &$3, &$4)
${0:${VISUAL}}
endsnippet

snippet fs5 "make five variables and use fmt.Scan(...)"
var ${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:e} int
fmt.Scan(&$1, &$2, &$3, &$4, &$5)
${0:${VISUAL}}
endsnippet

snippet si "scan standard input as integer"
var sc = bufio.NewScanner(os.Stdin)

func scanInt() int {
	sc.Scan()
	iv, _ := strconv.Atoi(sc.Text())
	return iv
}

func init() {
	sc.Split(bufio.ScanWords)
}
${0:${VISUAL}}
endsnippet

snippet si1 "... := scanInt()"
${1:n} := scanInt()
${0:${VISUAL}}
endsnippet

snippet si2 "... := scanInt(), scanInt()"
${1:x}, ${2:y} := scanInt(), scanInt()
${0:${VISUAL}}
endsnippet

snippet si3 "... := scanInt(), scanInt(), scanInt()"
${1:x}, ${2:y}, ${3:z} := scanInt(), scanInt(), scanInt()
${0:${VISUAL}}
endsnippet

snippet ss "scan standard input as string"
var sc = bufio.NewScanner(os.Stdin)

func scanString() string {
	sc.Scan()
	return sc.Text()
}

func init() {
	sc.Split(bufio.ScanWords)
}
${0:${VISUAL}}
endsnippet

snippet ss1 "... := scanString()"
${1:n} := scanString()
${0:${VISUAL}}
endsnippet

snippet ss2 "... := scanString(), scanString()"
${1:x}, ${2:y} := scanString(), scanString()
${0:${VISUAL}}
endsnippet

snippet ss3 "... := scanString(), scanString(), scanString()"
${1:x}, ${2:y}, ${3:z} := scanString(), scanString(), scanString()
${0:${VISUAL}}
endsnippet

snippet sis "read standard input by scanner and return value as integer or string"
var sc = bufio.NewScanner(os.Stdin)

func scanInt() int {
	iv, _ := strconv.Atoi(scanString())
	return iv
}

func scanString() string {
	sc.Scan()
	return sc.Text()
}

func init() {
	sc.Split(bufio.ScanWords)
}

${1:n}, ${2:s} := scanInt(), scanString()
endsnippet

snippet type "type T struct { ... }"
type ${1:Type} struct { ${0} }
${0:${VISUAL}}
endsnippet

snippet ms "make slice"
${1:xs} := make([]${3:int}, ${2:n})
${0:${VISUAL}}
endsnippet

snippet mm "make map"
${1:xm} := make(map[${2:int}]${3:int})
${0:${VISUAL}}
endsnippet

snippet mmm "make mapped map"
${1:xm} := make(map[int]map[int]bool, ${2:n})
for i := 0; i < ${3:m}; i++ {
	${4:a}, ${5:b} := scanInt(), scanInt()
	if _, ok := $1[$4]; !ok {
		$1[$4] = make(map[int]bool)
	}
	$1[$4][$5] = true
}
${0:${VISUAL}}
endsnippet

snippet if "if ... { ... }"
if ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

snippet else
else {
	${0:${VISUAL}}
}
endsnippet

snippet switch "switch x { ... }"
switch ${1:var} {
case ${2:value1}:
	${0}
}
endsnippet

snippet for "for ... { ... }"
for ${1} {
	${0:${VISUAL}}
}
endsnippet

snippet fori "for 0..n-1 { ... }"
for ${1:i} := 0; $1 < ${2:n}; $1++ {
	${0:${VISUAL}}
}
endsnippet

snippet forir "for n..0 { ... }"
for ${1:i} := ${2:n}; $1 >= 0; $1-- {
	${0:${VISUAL}}
}
endsnippet

snippet forr "for i, v := range items { ... }"
for ${2:i}, ${3:v} := range ${1:xs} {
	${0:${VISUAL}}
}
endsnippet

snippet forri "for i := range items { ... }"
for ${2:i} := range ${1:xs} {
	${0:${VISUAL}}
}
endsnippet

snippet forrv "for _, v := range items { ... }"
for _, ${2:v} := range ${1:xs} {
	${0:${VISUAL}}
}
endsnippet

snippet sort "type and methods for sort"
type ${1:data} struct{ ${2:x}, ${3:y} int }
type ${4:datas} []$1

func (${5:d} $4) Len() int           { return len($5) }
func ($5 $4) Swap(i, j int)      { $5[i], $5[j] = $5[j], $5[i] }
func ($5 $4) Less(i, j int) bool { return $5[i].$2 < $5[j].$2 }

${6:xs}:= $4(make([]$1, ${7:n}))
sort.Sort($6)
endsnippet

snippet sortr "sort reversely for Ints"
sort.Sort(sort.Reverse(sort.IntSlice(${1:xs})))
${0:${VISUAL}}
endsnippet

snippet sorts "sort string by character"
type sortString []rune

func (s sortString) Len() int           { return len(s) }
func (s sortString) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
func (s sortString) Less(i, j int) bool { return s[i] < s[j] }

ss := sortString(${1:s})
sort.Sort(ss)
fmt.Println(string(ss)))
endsnippet

snippet sortsr "sort string by character reversely"
type sortStringR []rune

func (s sortStringR) Len() int           { return len(s) }
func (s sortStringR) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
func (s sortStringR) Less(i, j int) bool { return s[i] > s[j] }

rs := sortStringR(${1:s})
sort.Sort(rs)
fmt.Println(string(rs)))
endsnippet

snippet que "get queue of integers"
qu := list.New()
for i := 0; i < ${1:n}; i++ {
	qu.PushBack(i)
}
fmt.Println(qu.Len())
x := qu.Remove(qu.Front()).(int)
fmt.Println(x, qu.Len())
endsnippet

snippet pq "get priority queue"
type ${1:data} struct{ ${2:x}, ${3:y} int }
type prQue []*$1

func (p prQue) Len() int            { return len(p) }
func (p prQue) Less(i, j int) bool  { return p[i].$2 > p[j].$2 }
func (p prQue) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }
func (p *prQue) Push(x interface{}) { *p = append(*p, x.(*$1)) }
func (p *prQue) Pop() interface{} {
	old := *p
	n := len(old)
	x := old[n-1]
	*p = old[0 : n-1]
	return x
}

pq := make(prQue, 0, ${4:n})
heap.Push(&pq, &$1{2, 1})
heap.Push(&pq, &$1{3, 2})
heap.Push(&pq, &$1{1, 3})
for len(pq) > 0 {
	v := heap.Pop(&pq).(*$1)
}
endsnippet

snippet pqi "get priority queue of integers"
type prQue []int

func (p prQue) Len() int            { return len(p) }
func (p prQue) Less(i, j int) bool  { return p[i] > p[j] }
func (p prQue) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }
func (p *prQue) Push(x interface{}) { *p = append(*p, x.(int)) }
func (p *prQue) Pop() interface{} {
	old := *p
	n := len(old)
	x := old[n-1]
	*p = old[0 : n-1]
	return x
}

pq := make(prQue, 0, ${1:n})
heap.Push(&pq, 1)
heap.Push(&pq, 3)
heap.Push(&pq, 2)
for len(pq) > 0 {
	v := heap.Pop(&pq).(int)
}
endsnippet

snippet abs "get absolute value of an integer"
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

abs(${1:n})
endsnippet

snippet max "get maximum value of two integers"
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

max(${1:a}, ${2:b})
endsnippet

snippet maxs "get maximum value of multiple integers"
func maxs(x ...int) int {
	mv := x[0]
	for _, v := range x[1:] {
		if v > mv {
			mv = v
		}
	}
	return mv
}

maxs(${1:a}, ${2:b}, ${3:c})
endsnippet

snippet min "get minimum value of two integers"
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

min(${1:a}, ${2:b})
endsnippet

snippet mins "get minimum value of multiple integers"
func mins(x ...int) int {
	mv := x[0]
	for _, v := range x[1:] {
		if v < mv {
			mv = v
		}
	}
	return mv
}

mins(${1:a}, ${2:b}, ${3:c})
endsnippet

snippet gcd "get GCD(Greatest Common Divisor)"
func gcd(x, y int) int {
	for y > 0 {
		x, y = y, x%y
	}
	return x
}

gcd(${1:a}, ${2:b})
endsnippet

snippet lcm "get LCM(Least Common Multiple)"
func gcd(x, y int) int {
	for y > 0 {
		x, y = y, x%y
	}
	return x
}

func lcm(x, y int) int {
	return x / gcd(x, y) * y
}

lcm(${1:a}, ${2:b})
endsnippet

snippet prm "get answer which is Prime Number or not"
func isPrime(x int) bool {
	if x < 2 {
		return false
	}

	for i := 2; i*i <= x; i++ {
		if x%i == 0 {
			return false
		}
	}
	return true
}

isPrime(${1:n})
endsnippet

snippet prf "get answer of Prime Factorization"
func prmFac(x int) map[int]bool {
	pfm := make(map[int]bool)
	pfm[1] = true
	for i := 2; i*i <= x; i++ {
		for x%i == 0 {
			x /= i
			pfm[i] = true
		}
	}
	if x > 1 {
		pfm[x] = true
	}
	return pfm
}

m := prmFac(${1:n})
endsnippet

snippet per "get permutations array"
func permutations(xs []int) [][]int {
	l := 1
	for i := 2; i <= len(xs); i++ {
		l *= i
	}
	ans := make([][]int, 0, l)

	var rec func([]int, int)
	rec = func(xs []int, n int) {
		if n == 1 {
			tmp := make([]int, len(xs))
			copy(tmp, xs)
			ans = append(ans, tmp)
			return
		}
		for i := 0; i < n; i++ {
			rec(xs, n-1)
			if n%2 == 1 {
				xs[i], xs[n-1] = xs[n-1], xs[i]
				continue
			}
			xs[0], xs[n-1] = xs[n-1], xs[0]
		}
	}
	rec(xs, len(xs))
	return ans
}

x := []int{${1:1, 2, 3}}
permutations(x)
endsnippet

snippet base "Get N-based numeral string"
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func base(x, b int) string {
	bs := ""
	for x > 0 {
		r := abs(x % b)
		bs = strconv.Itoa(r) + bs
		x -= r
		x /= b
	}
	if bs == "" {
		bs = "0"
	}
	return bs
}

base(${1:n}, ${2:2})
endsnippet

snippet pow "get x**y the base-x exponential of y by mod"
const mod = 1000000007

func pow(x, y int) int {
	if y == 0 {
		return 1
	} else if y%2 == 0 {
		x2 := pow(x, y/2)
		return x2 * x2 % mod
	} else {
		return x * pow(x, y-1) % mod
	}
}

pow(${1:2}, ${2:n})
endsnippet

snippet cmb "get combination value by using inverse element"
const mod = 1000000007

func pow(x, y int) int {
	if y == 0 {
		return 1
	} else if y%2 == 0 {
		x2 := pow(x, y/2)
		return x2 * x2 % mod
	} else {
		return x * pow(x, y-1) % mod
	}
}

func cmb(x, y int) int {
	if y > x {
		return 0
	}

	nu, de := 1, 1
	for i := 0; i < y; i++ {
		nu = nu * (x - i) % mod
		de = de * (i + 1) % mod
	}
	return nu * pow(de, mod-2) % mod
}

cmb(${1:n}, ${2:k})
endsnippet

snippet cmbs "get combination value by using inverse element and slice"
const mod = 1000000007

var fac, finv, inv []int

func initCmb(x int) {
	fac, finv, inv = make([]int, x+1), make([]int, x+1), make([]int, x+1)
	fac[0], fac[1] = 1, 1
	finv[0], finv[1] = 1, 1
	inv[1] = 1
	for i := 2; i <= x; i++ {
		fac[i] = fac[i-1] * i % mod
		inv[i] = mod - inv[mod%i]*(mod/i)%mod
		finv[i] = finv[i-1] * inv[i] % mod
	}
}

func cmb(x, y int) int {
	if y > x {
		return 0
	}
	return fac[x] * (finv[y] * finv[x-y] % mod) % mod
}

initCmb(${1:n})
cmb($1, ${2:k})
endsnippet

snippet cmbp "get combination value by Pascal's triangle"
const mod = 1000000007

var cs [][]int

func initCmb(x int) {
	cs = make([][]int, x+1)
	for i := range cs {
		cs[i] = make([]int, i+1)
		cs[i][0], cs[i][len(cs[i])-1] = 1, 1
		for j := 1; j < len(cs[i])-1; j++ {
			cs[i][j] = (cs[i-1][j-1] + cs[i-1][j]) % mod
		}
	}
}

func cmb(x, y int) int {
	if y > x {
		return 0
	}
	return cs[x][y]
}

initCmb(${1:n})
cmb($1, ${2:k})
endsnippet

snippet fac "get factorial value"
func fac(x int) int {
	fv := 1
	for i := x; i > 0; i-- {
		fv *= i
	}
	return fv
}

fac(${1:n})
endsnippet

snippet fib "get fibonacci value"
func fib(x int) int {
	a, b := 0, 1
	for i := 0; i < x; i++ {
		a, b = b, a+b
	}
	return a
}

fib(${1:n})
endsnippet

snippet gr "Data structure for graph"
var G map[int]map[int]bool

func initGraph(x int) {
	G = make(map[int]map[int]bool, x)
}

func add(from, to int) {
	if _, ok := G[from]; !ok {
		G[from] = make(map[int]bool)
	}
	G[from][to] = true
}

${1:n}, ${2:m} := scanInt(), scanInt()
initGraph($1)
for i := 0; i < $2; i++ {
	${3:a}, ${4:b} := scanInt(), scanInt()
	add($3, $4)
	add($4, $3)
}
endsnippet

snippet grw "Data structure for graph with weight"
var G map[int]map[int]int

func initGraph(x int) {
	G = make(map[int]map[int]int, x)
}

func add(from, to, weight int) {
	if _, ok := G[from]; !ok {
		G[from] = make(map[int]int)
	}
	G[from][to] = weight
}

${1:n}, ${2:m} := scanInt(), scanInt()
initGraph($1)
for i := 0; i < $2; i++ {
	${3:a}, ${4:b}, ${5:c} := scanInt(), scanInt(), scanInt()
	add($3, $4, $5)
	add($4, $3, $5)
}
endsnippet

snippet dfs "Depth First Search in graph"
var seen map[int]bool

func dfs(v int) {
	seen[v] = true
	for t := range G[v] {
		if seen[t] {
			continue
		}
		dfs(t)
	}
}

seen = make(map[int]bool, n)
dfs(1)
endsnippet

snippet sdfs "Get shortest path in graph by Depth First Search"
var depth []int

func dfs(v, p, d int) {
	depth[v] = d
	for t, w := range G[v] {
		if t == p {
			continue
		}
		dfs(t, v, d+w)
	}
}

depth = make([]int, n+1)
dfs(${1:k}, -1, 0)
fmt.Println(depth)
endsnippet

snippet bfs "Breadth First Search in graph"
seen := make(map[int]bool, n)
qu := list.New()
qu.PushBack(${1:1})
seen[$1] = true
for qu.Len() > 0 {
	v := qu.Remove(qu.Front()).(int)
	for t := range G[v] {
		if seen[t] {
			continue
		}
		seen[t] = true
		qu.PushBack(t)
	}
}
${0:${VISUAL}}
endsnippet

snippet war "Warshall Floyd Algorithm"
for k := 0; k < ${1:n}; k++ {
	for i := 0; i < $1; i++ {
		for j := 0; j < $1; j++ {
			${2:dist}[i][j] = min($2[i][j], $2[i][k]+$2[k][j])
		}
	}
}
${0:${VISUAL}}
endsnippet

snippet uft "get Union Find Tree"
var (
	par  []int
	rank []int
)

func initTree(x int) {
	par = make([]int, x+1)
	rank = make([]int, x+1)
	for i := range par {
		par[i] = i
	}
}

func find(x int) int {
	if par[x] == x {
		return x
	}
	par[x] = find(par[x])
	return par[x]
}

func union(x, y int) {
	px, py := find(x), find(y)
	if px == py {
		return
	}
	if rank[px] < rank[py] {
		par[px] = py
		return
	} else if rank[px] == rank[py] {
		rank[px]++
	}
	par[py] = px
}

initTree(${1:n})
union(1, 2)
union(2, 3)
union(4, 5)
for i := 1; i <= $1; i++ {
	f := find(i)
}
endsnippet

snippet fn "fmt.Println(...)"
fmt.Println(${1:ans})
endsnippet

snippet ff "fmt.Printf(...)"
fmt.Printf("%v\n", ${1:ans})
endsnippet

snippet wr "write standard output by writer"
var wr = bufio.NewWriter(os.Stdout)

wr.WriteString(strconv.Itoa(${1:n}) + "\n")
wr.Flush()
endsnippet

global !p

import re

# Automatically wrap return types with parentheses

def return_values(s):
	# remove everything wrapped in parentheses
	s = re.sub("\(.*?\)|\([^)]*$", "", s)
	return len(s.split(","))

def opening_par(snip, pos):
	if return_values(t[pos]) > 1 and not t[pos].startswith("("):
		snip.rv = "("
	else:
		snip.rv = ""

def closing_par(snip, pos):
	if return_values(t[pos]) > 1:
		snip.rv = ")"
	else:
		snip.rv = ""

endglobal

# vim:ft=snippets:
