# Snippets for Go

priority -10

# shorthand variable declaration
snippet : "v := value"
${1} := ${0}
endsnippet

# anonymous function
snippet anon "fn := func() { ... }"
${1:fn} := func() {
	${2:${VISUAL}}
}
${0}
endsnippet

# append
snippet ap "append(slice, value)"
append(${1:slice}, ${0:value})
endsnippet

# append assignment
snippet ap= "a = append(a, value)"
${1:slice} = append($1, ${0:value})
endsnippet

# break
snippet br "break"
break
endsnippet

# channel
snippet ch "chan Type"
chan ${0:int}
endsnippet

# case
snippet case "case ...:"
case ${1:value}:
	${0:${VISUAL}}
endsnippet

# constant
snippet con "const XXX Type = ..."
const ${1:NAME} ${2:Type} = ${0:0}
endsnippet

# constants
snippet cons "const ( ... )"
const (
	${1:NAME} ${2:Type} = ${3:value}
	${0}
)
endsnippet

# constants with iota
snippet iota "const ( ... = iota )"
const (
	${1:NAME} ${2:Type} = iota
	${0}
)
endsnippet

# continue
snippet cn "continue"
continue
endsnippet

# default case
snippet default "default: ..."
default:
	${0:${VISUAL}}
endsnippet

# defer
snippet df "defer someFunction()"
defer ${1:func}(${2})
${0}
endsnippet

snippet def "defer func() { ... }"
defer func() {
	${0:${VISUAL}}
}()
endsnippet

# defer recover
snippet defr
defer func() {
	if err := recover(); err != nil {
		${0:${VISUAL}}
	}
}()
endsnippet

# gpl
snippet gpl
/*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, see <http://www.gnu.org/licenses/>.
*
* Copyright (C) ${1:Author}, `!v strftime("%Y")`
*/
${0}
endsnippet

# import
snippet import "import ( ... )"
import (
	"${1:package}"
)
endsnippet

# full interface snippet
snippet interface "interface I { ... }"
type ${1:Interface} interface {
	${2:/* TODO: add methods */}
}
endsnippet

# if condition
snippet if "if ... { ... }"
if ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

# else snippet
snippet else
else {
	${0:${VISUAL}}
}
endsnippet

# if inline error
snippet ife "If with inline erro"
if err := ${1:condition}; err != nil {
	${0:${VISUAL}}
}
endsnippet

# error snippet
snippet errn "Error return" !b
if err != nil {
	return err
}
${0}
endsnippet

# error log snippet
snippet errl "Error with log.Fatal(err)" !b
if err != nil {
	log.Fatal(err)
}
${0}
endsnippet

# error multiple return
snippet errn, "Error return with two return values" !b
if err != nil {
	return ${1:nil}, ${2:err}
}
${0}
endsnippet

# error panic
snippet errp "Error panic" !b
if err != nil {
	panic(${1})
}
${0}
endsnippet

# error test
snippet errt "Error test fatal " !b
if err != nil {
	t.Fatal(err)
}
${0}
endsnippet

# error handle
snippet errh "Error handle and return" !b
if err != nil {
	${1}
	return
}
${0}
endsnippet

# json field tag
snippet json "\`json:key\`"
\`json:"${1:`!v  go#util#snippetcase(matchstr(getline("."), '\w\+'))`}"\`
endsnippet

# yaml field tag
snippet yaml "\`yaml:key\`"
\`yaml:"${1:`!v  go#util#snippetcase(matchstr(getline("."), '\w\+'))`}"\`
endsnippet

# fallthrough
snippet ft "fallthrough"
fallthrough
endsnippet

# for loop
snippet for "for ... { ... }"
for ${1} {
	${0:${VISUAL}}
}
endsnippet

# for integer loop
snippet fori "for 0..N-1 { ... }"
for ${1:i} := 0; $1 < ${2:N}; $1++ {
	${0:${VISUAL}}
}
endsnippet

# for range loop
snippet forr "for k, v := range items { ... }"
for ${2:k}, ${3:v} := range ${1} {
	${0:${VISUAL}}
}
endsnippet

# function
snippet func "func Function(...) [error] { ... }"
func ${1:name}(${2:params})${3/(.+)/ /}`!p opening_par(snip, 3)`$3`!p closing_par(snip, 3)` {
	${0:${VISUAL}}
}
endsnippet

# Fmt Printf debug
snippet ff "fmt.Printf(...)"
fmt.Printf("${1:${VISUAL}} = %+v\n", $1)
endsnippet

# Fmt Println debug
snippet fn "fmt.Println(...)"
fmt.Println("${1:${VISUAL}}")
endsnippet

# Fmt Errorf debug
snippet fe "fmt.Errorf(...)"
fmt.Errorf("${1:${VISUAL}}")
endsnippet

# log printf
snippet lf "log.Printf(...)"
log.Printf("${1:${VISUAL}} = %+v\n", $1)
endsnippet

# log println
snippet ln "log.Println(...)"
log.Println("${1:${VISUAL}}")
endsnippet

# make
snippet make "make(Type, size)"
make(${1:[]string}, ${2:0})${0}
endsnippet

# map
snippet map "map[Type]Type"
map[${1:string}]${0:int}
endsnippet

# main()
snippet main "func main() { ... }"
func main() {
	${0:${VISUAL}}
}
endsnippet

# method
snippet meth "func (self Type) Method(...) [error] { ... }"
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}`!p opening_par(snip, 5)`$5`!p closing_par(snip, 5)` {
	${0:${VISUAL}}
}
endsnippet

# ok
snippet ok "if !ok { ... }"
if !ok {
	${0:${VISUAL}}
}
endsnippet

# package
snippet package "package ..."
// Package $1 provides ${2:...}
package ${1:main}
${0}
endsnippet

# panic
snippet pn "panic()"
panic("${0:msg}")
endsnippet

# return
snippet rt "return"
return ${0:${VISUAL}}
endsnippet

# select
snippet select "select { case a := <-chan: ... }"
select {
case ${1:v1} := <-${2:chan1}
	${0}
}
endsnippet

# struct
snippet st "type T struct { ... }"
type ${1:Type} struct {
	${0}
}
endsnippet

# switch
snippet switch "switch x { ... }"
switch ${1:var} {
case ${2:value1}:
	${0}
}
endsnippet

# sprintf
snippet sp "fmt.Sprintf(...)"
fmt.Sprintf("%${1:s}", ${2:var})
endsnippet

# goroutine named function
snippet go "go someFunc(...)"
go ${1:funcName}(${0})
endsnippet

# goroutine anonymous function
snippet gof "go func() { ... }()"
go func() {
	${1:${VISUAL}}
}()
${0}
endsnippet

# test function
snippet test "func TestXYZ(t *testing.T) { ... }"
func Test${1:Function}(t *testing.T) {
	${0:${VISUAL}}
}
endsnippet

# test table snippet
snippet tt
var tests = []struct {
	name string
	expected string
	given string
}{
	{"${1}", "${2}", "${3}",},
}
for _, tt := range tests {
	tt := tt
	t.Run(tt.name, func(t *testing.T){
		actual := ${0:${VISUAL}}(tt.given)
		if actual != tt.expected {
				t.Errorf("$0(%s): expected %s, actual %s", tt.given, tt.expected, actual)
		}

	})
}
endsnippet


snippet hf "http.HandlerFunc" !b
func ${1:handler}(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintf(w, "hello world")}
}
endsnippet

snippet hhf "mux.HandleFunc" !b
${1:http}.HandleFunc("${2:/}", func(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintf(w, "hello world")}
})
endsnippet

# quick test server
snippet tsrv "httptest.NewServer"
ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, ${1:`response`})
}))
defer ts.Close()

${0:someUrl} = ts.URL
endsnippet

# test error handling
snippet ter "if err != nil { t.Errorf(...) }"
if err != nil {
	t.Errorf("${0:message}")
}
endsnippet

# test fatal error
snippet terf "if err != nil { t.Fatalf(...) }"
if err != nil {
	t.Fatalf("${0:message}")
}
endsnippet

snippet example "func ExampleXYZ() { ... }"
func Example${1:Method}() {
	${0:${VISUAL}}
	// Output:
}
endsnippet

snippet benchmark "func BenchmarkXYZ(b *testing.B) { ... }"
func Benchmark${1:Method}(b *testing.B) {
	for i := 0; i < b.N; i++ {
		${0:${VISUAL}}
	}
}
endsnippet

# variable declaration
snippet var "var x Type [= ...]"
var ${1:x} ${2:Type}${3: = ${0:value}}
endsnippet

# variables declaration
snippet vars "var ( ... )"
var (
	${1:x} ${2:Type}${3: = ${0:value}}
)
endsnippet

# equals fails the test if exp is not equal to act.
snippet eq "equals: test two identifiers with DeepEqual"
if !reflect.DeepEqual(${1:expected}, ${2:actual}) {
	_, file, line, _ := runtime.Caller(0)
	fmt.Printf("%s:%d:\n\n\texp: %#v\n\n\tgot: %#v\n\n", filepath.Base(file), line, $1, $2)
	t.FailNow()
}
endsnippet

snippet abs "get absolute value of an integer"
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

abs(${1:n})
endsnippet

snippet max "get maximum value of two integers"
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

max(${1:a}, ${2:b})
endsnippet

snippet maxs "get maximum value of multiple integers"
func max(x ...int) int {
	mv := x[0]
	for _, v := range x[1:] {
		if v > mv {
			mv = v
		}
	}
	return mv
}

max(${1:a}, ${2:b}, ${3:c})
endsnippet

snippet min "get minimum value of two integers"
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

min(${1:a}, ${2:b})
endsnippet

snippet mins "get minimum value of multiple integers"
func min(x ...int) int {
	mv := x[0]
	for _, v := range x[1:] {
		if v < mv {
			mv = v
		}
	}
	return mv
}

min(${1:a}, ${2:b}, ${3:c})
endsnippet

snippet base "Get N-based numeral string"
func base(x, b int) string {
	abs := func(x int) int {
		if x < 0 {
			return -x
		}
		return x
	}

	bs := ""
	for x != 0 {
		r := abs(x % b)
		bs = strconv.Itoa(r) + bs
		x -= r
		x /= b
	}
	if bs == "" {
		bs = "0"
	}
	return bs
}

base(${1:n}, ${2:2})
endsnippet

snippet per "get permutations array"
func permutations(xs []int) [][]int {
	l := 1
	for i := 2; i <= len(xs); i++ {
		l *= i
	}
	ans := make([][]int, 0, l)

	var rec func([]int, int)
	rec = func(xs []int, n int) {
		if n == 1 {
			tmp := make([]int, len(xs))
			copy(tmp, xs)
			ans = append(ans, tmp)
			return
		}
		for i := 0; i < n; i++ {
			rec(xs, n-1)
			if n%2 == 1 {
				xs[i], xs[n-1] = xs[n-1], xs[i]
				continue
			}
			xs[0], xs[n-1] = xs[n-1], xs[0]
		}
	}
	rec(xs, len(xs))
	return ans
}

x := []int{${1:1, 2, 3}}
fmt.Println(permutations(x))
endsnippet

snippet cmb "get combination value by using inverse element"
const mod = 1000000007

var fac, finv, inv []int

func initCmb(x int) {
	fac, finv, inv = make([]int, x+1), make([]int, x+1), make([]int, x+1)
	fac[0], fac[1] = 1, 1
	finv[0], finv[1] = 1, 1
	inv[1] = 1
	for i := 2; i <= x; i++ {
		fac[i] = fac[i-1] * i % mod
		inv[i] = mod - inv[mod%i]*(mod/i)%mod
		finv[i] = finv[i-1] * inv[i] % mod
	}
}

func cmb(x, y int) int {
	if y > x {
		return 0
	}
	return fac[x] * (finv[y] * finv[x-y] % mod) % mod
}

initCmb(${1:n})
cmb($1, ${2:k})
endsnippet

snippet pas "get combination value by Pascal's triangle"
const mod = 1000000007

var cs [][]int

func initCmb(x int) {
	cs = make([][]int, x+1)
	for i := range cs {
		cs[i] = make([]int, i+1)
		cs[i][0], cs[i][len(cs[i])-1] = 1, 1
		for j := 1; j < len(cs[i])-1; j++ {
			cs[i][j] = (cs[i-1][j-1] + cs[i-1][j]) % mod
		}
	}
}

func cmb(x, y int) int {
	if y > x {
		return 0
	}
	return cs[x][y]
}

initCmb(${1:n})
cmb($1, ${2:k})
endsnippet

snippet fac "get factorial value"
func fac(x int) int {
	fv := 1
	for i := x; i > 0; i-- {
		fv *= i
	}
	return fv
}

fac(${1:n})
endsnippet

snippet fib "get fibonacci value"
func fib(x int) int {
	a, b := 0, 1
	for i := 0; i < x; i++ {
		a, b = b, a+b
	}
	return a
}

fib(${1:n})
endsnippet

snippet gcd "get GCD(Greatest Common Divisor)"
func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

gcd(${1:a}, ${2:b})
endsnippet

snippet lcm "get LCM(Least Common Multiple)"
func lcm(x, y int) int {
	gcd := func(x, y int) int {
		for y != 0 {
			x, y = y, x%y
		}
		return x
	}
	return x * y / gcd(x, y)
}

lcm(${1:a}, ${2:b})
endsnippet

snippet prm "get answer which is Prime Number or not"
func isPrime(x int) bool {
	if x < 2 {
		return false
	}

	for i := 2; i*i <= x; i++ {
		if x%i == 0 {
			return false
		}
	}
	return true
}

isPrime(${1:n})
endsnippet

snippet prf "get answer of Prime Factorization"
func prmFac(x int) map[int]bool {
	pfm := make(map[int]bool)
	pfm[1] = true
	for i := 2; i*i <= x; i++ {
		for x%i == 0 {
			x /= i
			pfm[i] = true
		}
	}
	if x > 1 {
		pfm[x] = true
	}
	return pfm
}

m := prmFac(${1:n})
for k := range m {
}
endsnippet

snippet pqi "get priority queue of integers"
type prQue []int

func (p prQue) Len() int            { return len(p) }
func (p prQue) Less(i, j int) bool  { return p[i] > p[j] }
func (p prQue) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }
func (p *prQue) Push(x interface{}) { *p = append(*p, x.(int)) }
func (p *prQue) Pop() interface{} {
	old := *p
	n := len(old)
	x := old[n-1]
	*p = old[0 : n-1]
	return x
}

pq := make(prQue, 0, ${1:n})
heap.Push(&pq, 1)
heap.Push(&pq, 3)
heap.Push(&pq, 2)
for len(pq) > 0 {
	v := heap.Pop(&pq).(int)
}
endsnippet

snippet pq "get priority queue"
type data struct{ a, b, c int }
type prQue []*data

func (p prQue) Len() int            { return len(p) }
func (p prQue) Less(i, j int) bool  { return p[i].a > p[j].a }
func (p prQue) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }
func (p *prQue) Push(x interface{}) { *p = append(*p, x.(*data)) }
func (p *prQue) Pop() interface{} {
	old := *p
	n := len(old)
	x := old[n-1]
	*p = old[0 : n-1]
	return x
}

pq := make(prQue, 0, ${1:n})
heap.Push(&pq, &data{1, 2, 3})
heap.Push(&pq, &data{2, 3, 4})
heap.Push(&pq, &data{1, 3, 4})
for len(pq) > 0 {
	v := heap.Pop(&pq).(*data)
}
endsnippet

snippet uft "get Union Find Tree"
var (
	par  []int
	rank []int
)

func initTree(x int) {
	par = make([]int, x+1)
	rank = make([]int, x+1)
	for i := range par {
		par[i] = i
	}
}

func find(x int) int {
	if par[x] == x {
		return x
	}
	par[x] = find(par[x])
	return par[x]
}

func union(x, y int) {
	px, py := find(x), find(y)
	if px == py {
		return
	}
	if rank[px] < rank[py] {
		par[px] = py
		return
	} else if rank[px] == rank[py] {
		rank[px]++
	}
	par[py] = px
}

initTree(${1:n})
union(1, 2)
union(2, 3)
union(4, 5)
for i := 1; i <= $1; i++ {
	f := find(i)
}
endsnippet

snippet ri "read standard input by scanner and return value as integer"
var sc = bufio.NewScanner(os.Stdin)

func readInt() int {
	sc.Scan()
	iv, _ := strconv.Atoi(sc.Text())
	return iv
}

func init() {
	sc.Split(bufio.ScanWords)
}

${1:n} := readInt()
endsnippet

snippet rs "read standard input by scanner and return value as string"
var sc = bufio.NewScanner(os.Stdin)

func readStr() string {
	sc.Scan()
	return sc.Text()
}

func init() {
	sc.Split(bufio.ScanWords)
}

${1:s} := readStr()
endsnippet

snippet wr "write standard output by writer"
var wr = bufio.NewWriter(os.Stdout)

for i := 0; i < ${1:n}; i++ {
	wr.WriteString(strconv.Itoa(i))
	if i < $1-1 {
		wr.WriteString(" ")
		continue
	}
	wr.WriteString("\n")
}
wr.WriteString(strconv.Itoa($1) + "\n")
wr.Flush()
endsnippet

global !p

import re

# Automatically wrap return types with parentheses

def return_values(s):
	# remove everything wrapped in parentheses
	s = re.sub("\(.*?\)|\([^)]*$", "", s)
	return len(s.split(","))

def opening_par(snip, pos):
	if return_values(t[pos]) > 1 and not t[pos].startswith("("):
		snip.rv = "("
	else:
		snip.rv = ""

def closing_par(snip, pos):
	if return_values(t[pos]) > 1:
		snip.rv = ")"
	else:
		snip.rv = ""

endglobal

# vim:ft=snippets:
