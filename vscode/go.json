{
	"Absolute value of an integer": {
		"prefix": "absolute",
		"body": [
			"func abs(x int) int {",
			"\tif x < 0 {",
			"\t\treturn -x",
			"\t}",
			"\treturn x",
			"}",
			"",
			"abs(${1:n})",
		],
		"description": "Get absolute value of an integer",
	},
	"Maximum value of two integers": {
		"prefix": "maximum",
		"body": [
			"func max(x, y int) int {",
			"\tif x > y {",
			"\t\treturn x",
			"\t}",
			"\treturn y",
			"}",
			"",
			"max(${1:a}, ${2:b})",
		],
		"description": "Get maximum value of two integers",
	},
	"Maximum value of multiple integers": {
		"prefix": "maximum of multiple integers",
		"body": [
			"func max(x ...int) int {",
			"\tmv := x[0]",
			"\tfor _, v := range x[1:] {",
			"\t\tif v > mv {",
			"\t\t\tmv = v",
			"\t\t}",
			"\t}",
			"\treturn mv",
			"}",
			"",
			"max(${1:a}, ${2:b}, ${3:c})",
		],
		"description": "Get maximum value of multiple integers",
	},
	"Minimum value of two integers": {
		"prefix": "minimum",
		"body": [
			"func min(x, y int) int {",
			"\tif x < y {",
			"\t\treturn x",
			"\t}",
			"\treturn y",
			"}",
			"",
			"min(${1:a}, ${2:b})",
		],
		"description": "Get minimum value of two integers",
	},
	"Minimum value of multiple integers": {
		"prefix": "minimum of multiple integers",
		"body": [
			"func min(x ...int) int {",
			"\tmv := x[0]",
			"\tfor _, v := range x[1:] {",
			"\t\tif v < mv {",
			"\t\t\tmv = v",
			"\t\t}",
			"\t}",
			"\treturn mv",
			"}",
			"",
			"min(${1:a}, ${2:b}, ${3:c})",
		],
		"description": "Get minimum value of multiple integers",
	},
	"N-based numeral string": {
		"prefix": "base",
		"body": [
			"func base(x, b int) string {",
			"\tabs := func(x int) int {",
			"\t\tif x < 0 {",
			"\t\t\treturn -x",
			"\t\t}",
			"\t\treturn x",
			"\t}",
			"",
			"\tbs := \"\"",
			"\tfor x != 0 {",
			"\t\tr := abs(x % b)",
			"\t\tbs = strconv.Itoa(r) + bs",
			"\t\tx -= r",
			"\t\tx /= b",
			"\t}",
			"\tif bs == \"\" {",
			"\t\tbs = \"0\"",
			"\t}",
			"\treturn bs",
			"}",
			"",
			"base(${1:n}, ${2:2})",
		],
		"description": "Get N-based numeral string",
	},
	"Combination value using inverse": {
		"prefix": "combination",
		"body": [
			"const mod = 1000000007",
			"",
			"var fac, finv, inv []int",
			"",
			"func initCmb(x int) {",
			"\tfac, finv, inv = make([]int, x+1), make([]int, x+1), make([]int, x+1)",
			"\tfac[0], fac[1] = 1, 1",
			"\tfinv[0], finv[1] = 1, 1",
			"\tinv[1] = 1",
			"\tfor i := 2; i <= x; i++ {",
			"\t\tfac[i] = fac[i-1] * i % mod",
			"\t\tinv[i] = mod - inv[mod%i]*(mod/i)%mod",
			"\t\tfinv[i] = finv[i-1] * inv[i] % mod",
			"\t}",
			"}",
			"",
			"func cmb(x, y int) int {",
			"\tif y > x {",
			"\t\treturn 0",
			"\t}",
			"\treturn fac[x] * (finv[y] * finv[x-y] % mod) % mod",
			"}",
			"",
			"initCmb(${1:n})",
			"cmb(${1:n}, ${2:k})",
		],
		"description": "Get combination value by using inverse element",
	},
	"Combination value by Pascal's triangle": {
		"prefix": "Pascal's triangle for combination",
		"body": [
			"const mod = 1000000007",
			"",
			"var cs [][]int",
			"",
			"func initCmb(x int) {",
			"\tcs = make([][]int, x+1)",
			"\tfor i := range cs {",
			"\t\tcs[i] = make([]int, i+1)",
			"\t\tcs[i][0], cs[i][len(cs[i])-1] = 1, 1",
			"\t\tfor j := 1; j < len(cs[i])-1; j++ {",
			"\t\t\tcs[i][j] = (cs[i-1][j-1] + cs[i-1][j]) % mod",
			"\t\t}",
			"\t}",
			"}",
			"",
			"func cmb(x, y int) int {",
			"\tif y > x {",
			"\t\treturn 0",
			"\t}",
			"\treturn cs[x][y]",
			"}",
			"",
			"initCmb(${1:n})",
			"cmb(${1:n}, ${2:k})",
		],
		"description": "Get combination value by Pascal's triangle",
	},
	"Factorial value": {
		"prefix": "factorial",
		"body": [
			"func fac(x int) int {",
			"\tfv := 1",
			"\tfor i := x; i > 0; i-- {",
			"\t\tfv *= i",
			"\t}",
			"\treturn fv",
			"}",
			"",
			"fac(${1:n})",
		],
		"description": "Get factorial value",
	},
	"Fibonacci value": {
		"prefix": "fibonacci",
		"body": [
			"func fib(x int) int {",
			"\ta, b := 0, 1",
			"\tfor i := 0; i < x; i++ {",
			"\t\ta, b = b, a+b",
			"\t}",
			"\treturn a",
			"}",
			"",
			"fib(${1:n})",
		],
		"description": "Get fibonacci value",
	},
	"GCD(Greatest Common Divisor)": {
		"prefix": "greatest common divisor",
		"body": [
			"func gcd(x, y int) int {",
			"\tfor y != 0 {",
			"\t\tx, y = y, x%y",
			"\t}",
			"\treturn x",
			"}",
			"",
			"gcd(${1:a}, ${2:b})",
		],
		"description": "Get GCD(Greatest Common Divisor)",
	},
	"LCM(Least Common Multiple)": {
		"prefix": "least common multiple",
		"body": [
			"func lcm(x, y int) int {",
			"\tgcd := func(x, y int) int {",
			"\t\tfor y != 0 {",
			"\t\t\tx, y = y, x%y",
			"\t\t}",
			"\t\treturn x",
			"\t}",
			"\treturn x * y / gcd(x, y)",
			"}",
			"",
			"lcm(${1:a}, ${2:b})",
		],
		"description": "Get LCM(Least Common Multiple)",
	},
	"Prime Factorization": {
		"prefix": "prime factorization",
		"body": [
			"func prmFac(x int) map[int]bool {",
			"\tpfm := make(map[int]bool)",
			"\tpfm[1] = true",
			"\tfor i := 2; i*i <= x; i++ {",
			"\t\tfor x%i == 0 {",
			"\t\t\tx /= i",
			"\t\t\tpfm[i] = true",
			"\t\t}",
			"\t}",
			"\tif x > 1 {",
			"\t\tpfm[x] = true",
			"\t}",
			"\treturn pfm",
			"}",
			"",
			"${1:pf} := prmFac(${2:n})",
			"for k := range ${1:pf} {",
			"}",
		],
		"description": "Get answer of Prime Factorization",
	},
	"Priority Queue of integers": {
		"prefix": "priority queue of integers",
		"body": [
			"type prQue []int",
			"",
			"func (p prQue) Len() int            { return len(p) }",
			"func (p prQue) Less(i, j int) bool  { return p[i] > p[j] }",
			"func (p prQue) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }",
			"func (p *prQue) Push(x interface{}) { *p = append(*p, x.(int)) }",
			"func (p *prQue) Pop() interface{} {",
			"\told := *p",
			"\tn := len(old)",
			"\tx := old[n-1]",
			"\t*p = old[0 : n-1]",
			"\treturn x",
			"}",
			"",
			"pq := make(prQue, 0, ${1:n})",
			"heap.Push(&pq, 1)",
			"heap.Push(&pq, 3)",
			"heap.Push(&pq, 2)",
			"for len(pq) > 0 {",
			"v := heap.Pop(&pq).(int)",
			"}",
		],
		"description": "Get priority queue of integers",
	},
	"Priority Queue": {
		"prefix": "priority queue",
		"body": [
			"type data struct{ a, b, c int }",
			"type prQue []*data",
			"",
			"func (p prQue) Len() int            { return len(p) }",
			"func (p prQue) Less(i, j int) bool  { return p[i].a > p[j].a }",
			"func (p prQue) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }",
			"func (p *prQue) Push(x interface{}) { *p = append(*p, x.(*data)) }",
			"func (p *prQue) Pop() interface{} {",
			"\told := *p",
			"\tn := len(old)",
			"\tx := old[n-1]",
			"\t*p = old[0 : n-1]",
			"\treturn x",
			"}",
			"",
			"pq := make(prQue, 0, ${1:n})",
			"heap.Push(&pq, &data{1, 2, 3})",
			"heap.Push(&pq, &data{2, 3, 4})",
			"heap.Push(&pq, &data{1, 3, 4})",
			"for len(pq) > 0 {",
			"v := heap.Pop(&pq).(*data)",
			"}",
		],
		"description": "Get priority queue",
	},
	"Union Find Tree": {
		"prefix": "union find tree",
		"body": [
			"var (",
			"\tpar  []int",
			"\trank []int",
			")",
			"",
			"func initTree(x int) {",
			"\tpar = make([]int, x+1)",
			"\trank = make([]int, x+1)",
			"\tfor i := range par {",
			"\t\tpar[i] = i",
			"\t}",
			"}",
			"",
			"func find(x int) int {",
			"\tif par[x] == x {",
			"\t\treturn x",
			"\t}",
			"\tpar[x] = find(par[x])",
			"\treturn par[x]",
			"}",
			"",
			"func union(x, y int) {",
			"\tpx, py := find(x), find(y)",
			"\tif px == py {",
			"\t\treturn",
			"\t}",
			"\tif rank[px] < rank[py] {",
			"\t\tpar[px] = py",
			"\t\treturn",
			"\t} else if rank[px] == rank[py] {",
			"\t\trank[px]++",
			"\t}",
			"\tpar[py] = px",
			"}",
			"",
			"initTree(${1:n})",
			"union(1, 2)",
			"union(2, 3)",
			"union(4, 5)",
			"for i := 1; i <= ${1:n}; i++ {",
			"find(i)",
			"}",
		],
		"description": "Get Union Find Tree",
	},
	"Read interger by scanner": {
		"prefix": "scanner for interger",
		"body": [
			"var sc = bufio.NewScanner(os.Stdin)",
			"",
			"func readInt() int {",
			"\tsc.Scan()",
			"\tiv, _ := strconv.Atoi(sc.Text())",
			"\treturn iv",
			"}",
			"",
			"func init() {",
			"\tsc.Split(bufio.ScanWords)",
			"}",
			"",
			"${1:n} := readInt()",
		],
		"description": "Read standard input by scanner and return value as integer",
	},
	"Read string by scanner": {
		"prefix": "scanner for string",
		"body": [
			"var sc = bufio.NewScanner(os.Stdin)",
			"",
			"func readStr() string {",
			"\tsc.Scan()",
			"\treturn sc.Text()",
			"}",
			"",
			"func init() {",
			"\tsc.Split(bufio.ScanWords)",
			"}",
			"",
			"${1:s} := readStr()",
		],
		"description": "Read standard input by scanner and return value as string",
	},
	"Write by writer": {
		"prefix": "writer",
		"body": [
			"var wr = bufio.NewWriter(os.Stdout)",
			"",
			"for i := 0; i < ${1:n}; i++ {",
			"\twr.WriteString(strconv.Itoa(i))",
			"\tif i < ${1:n}-1 {",
			"\t\twr.WriteString(\" \")",
			"\t\tcontinue",
			"\t}",
			"\twr.WriteString(\"\\n\")",
			"}",
			"wr.WriteString(strconv.Itoa(${1:n}) + \"\\n\")",
			"wr.Flush()",
		],
		"description": "Write standard output by writer",
	},
}
